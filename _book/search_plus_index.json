{"./":{"url":"./","title":"介绍","keywords":"","body":"Introduction All for the purpose not to marry out of love is where bullying 所有不知应用场景的学习，都是瞎学 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/":{"url":"mysql/","title":"1.1 安装配置","keywords":"","body":"Introduction window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-windos-install.html":{"url":"mysql/mysql-windos-install.html","title":"1.1.1 windos 安装","keywords":"","body":"1.1.1 MySQL之windows版本安装 1. 下载 MySQL-download 2. 解压到安装目录 本人解压到D:\\MySQL\\mysql-5.7.29-winx64 注：别虎不拉基的用中文命名 3. 配置文件 my.ini文件内容 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=D:\\\\MySQL\\\\mysql-5.7.29-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\\\MySQL\\\\mysql-5.7.29-winx64\\\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 4. 配置文件 变量名： MYSQL_HOME 变量值: D:\\MySQL\\mysql-5.7.29-winx64 path中添加: %MYSQL_HOME%\\bin 5. 初始化及相应配置 初始化命令mysqld --initialize --user=mysql --console 此处本人还报了错误：由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题 添加服务mysqld -install 启动服务net start mysql 登录数据库mysql -u root -p 密码为初始化密码(上上图) 修改密码：alter user 'root'@'localhost' identified with mysql_native_password by '1qaz2wsx'; 刷新：FLUSH PRIVILEGES; window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-ubuntu-install.html":{"url":"mysql/mysql-ubuntu-install.html","title":"1.1.2 ubuntu 安装","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-centos-install.html":{"url":"mysql/mysql-centos-install.html","title":"1.1.3 centos 安装","keywords":"","body":"[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm [root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm [root@localhost ~]# yum -y install mysql-community-server [root@localhost ~]# systemctl start mysqld.service //启动MySQL [root@localhost ~]# systemctl status mysqld.service //运行状态 [root@localhost ~]# grep \"password\" /var/log/mysqld.log // 初始密码 更改配置文件 vim /etc/my.cnf [mysqld] character_set_server=utf8 // 添加 collation-server=utf8_general_ci // 添加 [client] default-character-set=utf8 // 添加 启动mysql sudo service mysqld start //启动mysql sudo service mysqld status //查看mysql状态 sudo systemctl enable mysqld //配置开机启动 删除mysql sudo yum remove mysql-community-* rm -rf /var/lib/mysql rm /etc/my.cnf window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-introduction.html":{"url":"mysql/mysql-introduction.html","title":"1.2 数据操作","keywords":"","body":"一、MySQL语言分类： DML：数据操作语言，对数据查询、增加、修改、删除，如select、insert、update、delete、explain plan DDL：数据库定义语言，数据库、表、索引、视图、存储过程、触发器的管理，如create、alter、truncate TCL：事务处理语言，对事务进行处理，包括begin[set] transaction、commit、rollback、savepoint DCL：数据控制语言，进行授权与权限回收，如grant、revoke 二、数据库的启动 ubuntu service mysql status 查看MySQL服务状态 service mysql stop 停止MySQL服务 service mysql start 启动MySQL服务 service mysql restart 重启MySQL服务 centos systemctl status mysqld.service 查看MySQL服务状态 systemctl stop mysqld.service 停止MySQL服务 systemctl start mysqld.service 启动MySQL服务 systemctl restart mysqld.service 重启MySQL服务 查看mysql 运行 ps -aux|grep mysql ps 查看当前系统中的进程 a 表示所有用户 -u 表示显示用户名 -x 表示显示所有的执行程序 三、配置文件介绍 查看配置文件 mysql --help|grep 'my.cnf' order of preference, my.cnf, $MYSQL_TCP_PORT, /etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf mysql默认会搜寻my.cnf的目录，顺序排前的优先。 配置文件路径，阿里云服务器mysql配置文件生效位置 /etc/my.cnf 主要配置信息说明: port 表示端口号，默认为3306 bind-address 表示服务器绑定的ip，默认为127.0.0.1 datadir 表示数据库保存路径，默认为/var/lib/mysql log_error 表示错误日志，默认为/var/log/mysqld.log socket /var/lib/mysql/mysql.sock 注： Ubuntu 配置文件 /etc/mysql/mysql.conf.d/mysqld.cnf 四、数据库登录 方法一 mysql -uroot -p 数据库名称 方法二 mysql -h主机名 -P端口号 -u用户名 -p密码 mysql -h主机地址 -u用户名 －p用户密码 –P端口 –D数据库 –e 'SQL 内容' 五、MySQL语句 登录数据库: mysql -uroot -p 退出数据库: quit 或者 exit 或者 ctr + d 创建数据库: create database 数据库名 charset=utf8; 使用数据库: use 数据库名; 删除数据库: drop database 数据库名; 创建表: create table 表名(字段名 字段类型 约束, ...); 修改表-添加字段: alter table 表名 add 字段名 字段类型 约束 修改表-修改字段类型: alter table 表名 modify 字段名 字段类型 约束 修改表-修改字段名和字段类型: alter table 表名 change 原字段名 新字段名 字段类型 约束 修改表-删除字段: alter table 表名 drop 字段名; 删除表: drop table 表名; 查询数据: select * from 表名; 或者 select 列1,列2,... from 表名; 插入数据: insert into 表名 values (...) 或者 insert into 表名 (列1,...) values(值1,...) 修改数据: update 表名 set 列1=值1,列2=值2... where 条件 删除数据: delete from 表名 where 条件 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-sqlparse.html":{"url":"mysql/mysql-sqlparse.html","title":"1.2.1 解析过程","keywords":"","body":"1.2.1 解析过程 一、解析过程 二、解析过程 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-dml.html":{"url":"mysql/mysql-dml.html","title":"1.2.2 DML语言 增删改语","keywords":"","body":"第四章 DML语言 一、 插入语句 1、语法 方式一： INSERT INTO 表名(字段名,...) VALUES(值,...); 方式二： INSERT INTO 表名 SET 字段名=值,字段名=值,...; 2、特点 1. 要求值的类型和字段的类型要一致或兼容 2. 字段的个数和顺序不一定与原始表中的字段个数和顺序一致，但必须保证值和字段一一对应 3. 假如表中有可以为null的字段，注意可以通过以下两种方式插入null值：     ①字段和值都省略、②字段写上，值使用null 4. 字段和值的个数必须一致 5. 字段名可以省略，默认所有列v 6. 方式一支持一次插入多行，语法如下：INSERT INTO 表名【(字段名,…)】 VALUES(值,…),(值,…),…; 7. 方式一支持子查询，语法如下：INSERT INTO 表名 查询语句; INSERT INTO beauty ( id, NAME, sex, borndate, phone, photo, boyfriend_id ) VALUES ( 15, '唐艺昕', '女', '1997-12-05', '15633029014', NULL, 2 ); INSERT INTO beauty SET id = 19, name = '张倩倩', sex = '女', borndate = '1997-12-05', phone = '15633029014', photo = null, boyfriend_id = 3; 二、 更新语句 单表更新 UPDATE 表名 SET 列 = 值,... WHERE 查询条件; 修改beauty表中姓唐的女神的电话为13899888899 UPDATE beauty SET phone = '13899888899' WHERE NAME LIKE '唐%'; 多表更新 UPDATE 表1 别名, 表2 别名 SET 列 = 值, ... WHERE 连接条件 AND 筛选条件 ; 修改张无忌的女朋友的手机号为13899888899，魅力值为1000 UPDATE boys bo, beauty b SET b.`phone` = '13899888899', bo.`userCP` = 1000 WHERE bo.`id` = b.`boyfriend_id` AND bo.`boyName` = '张无忌'; UPDATE 表1 别名 INNER | LEFT | RIGHT JOIN 表2 别名 ON 连接条件 SET 列 = 值, ... WHERE 筛选条件 ; 修改张无忌的女朋友的手机号为13899888899，魅力值为1000 UPDATE boys bo INNER JOIN beauty b ON bo.`id` = b.`boyfriend_id` SET b.`phone` = '13899888899', bo.`userCP` = 1000 WHERE bo.`boyName` = '张无忌'; 三、删除语句 单表删除 DELETE FROM 表名 【WHERE 筛选条件 】; 删除手机号以9结尾的女神信息 DELETE FROM beauty WHERE phone LIKE '%9'; 多表删除（级联删除） DELETE 表1的别名, 表2的别名 FROM 表1 别名, 表2 别名 WHERE 连接条件 AND 筛选条件 ; DELETE b, bo FROM beauty b, boys bo WHERE b.`boyfriend_id` = bo.`id` AND bo.`boyName` = '黄晓明'; DELETE 表1的别名, 表2的别名 FROM 表1 别名 INNER | LEFT | RIGHT JOIN 表2 别名 ON 连接条件 WHERE 筛选条件 ; 删除黄晓明的信息以及他女朋友的信息 DELETE b, bo FROM beauty b INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id` WHERE bo.`boyName` = '黄晓明'; 删除重复数据，保留最后一条记录 删除重复数据，保留最后一条记录 delete from users where id not in ( select t.max_id from (select max(id) as max_id from users group by identity_id,name) as t ); 四、创建视图 创建视图(视图本质查询快照) create view vw_emp_dept as select eno, ename, dname from tb_emp t1 inner join tb_dept t2 on t1.dno=t2.dno; 查询语句 select ename，dname from vw_emp_dept; 删除视图 drop view vw_emp_dept; window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-dql.html":{"url":"mysql/mysql-dql.html","title":"1.2.3 DQL语言 基础查询","keywords":"","body":"DQL语言 其一 一、基础查询 - SELECT 查询列表 FROM 表名; - 查询列表可以是字段、常量、函数、表达式 - 查询结果是一个虚拟表 查询单个字段 SELECT 字段名 FROM 表名; 查询多个字段 SELECT 字段名,字段名 FROM 表名; 查询所有字段 SELECT * FROM 表名; 查询常量 SELECT 常量值; 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要 查询函数 SELECT 函数名(实参列表); 查询表达式 SELECT 100/25; 起别名 SELECT 字段名 AS \"别名\" FROM 表名; 注意：别名可以使用单引号、双引号引起 来当只有一个单词时，可以省略 引号当有多个单词且有空格或特殊符号时，不 能省略AS可以省略 去重复 SELECT DISTINCT 字段名 FROM 表名; 做加法 SELECT 数值+数值; 直接运算 SELECT 字符+数值; 首先先将字符转换为整数，如果转换成功，则继续运算，如果转换失败，则默认为0，然后继续运算 SELECT NULL+数值; NULL和任何数值参与运算结果都是NULL 【补充】ifnull函数 SELECT IFNULL(字段名, 指定值) FROM 表名; 判 断某字段或表达式是否为null，如果为null，返回指定的值，否则返回原本的值 【补充】isnull函数 SELECT ISNULL(字段名) FROM 表名;判 断某字段或表达式是否为null，如果是null，则返回1，否则返回0 二、条件查询 条件运算符：> >= != <> 查询工资>12000的员工信息 SELECT FROM employees WHERE salary > 12000 ; 逻辑运算符：and、or、not 查询工资>12000 and 工资 12000 AND salary =18000的员工信息 SELECT FROM employees WHERE salary > 12000 OR salary =18000的员工信息 SELECT * FROM employees WHERE NOT (salary > 12000 AND salary like：%任意多个字符、_任意单个字符，如果有特殊字符，需要使用escape转义 查询员工名中第一个字符为B、第四个字符为d的员工信息 SELECT * FROM employees WHERE last_name LIKE 'B__d%' ; between and 查询员工编号在100到120之间的员工信息 SELECT FROM employees WHERE employee_id BETWEEN 100 AND 120 ; NOT BETWEEN 100 AND 120 查询员工编号不在100到120之间的员工信息 SELECT FROM employees WHERE employee_id NOT BETWEEN 100 AND 120 ; IN 查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号 SELECT last_name, job_id FROM employees WHERE job_id IN ('IT_PROT', 'AD_VP', 'AD_PRES') ; in列表的值类型必须一致或兼容，in列表中不支持通配符%和_ IS NULL 查询没有奖金的员工名和奖金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NULL ; IS NOT NULL SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NOT NULL ; =、!=不能用来判断NULL 、is null 、is not null可以用来判断NULL 三、排序查询 SELECT 查询列表 FROM 表 【WHERE 筛选条件】ORDER BY 排序列表 【asc | desc】 ; 排序列表可以是单个字段、多个字段、别名、函数、表达式 asc代表升序，desc代表降序，如果不写，默认是asc order by的位置一般放在查询语句的最后（除limit语句之外） ORDER BY ... DESC 按单个字段排序：查询员工信息，要求按工资降序 SELECT FROM employees ORDER BY salary DESC ; 按多个字段查询：查询员工信息，要求先按工资降序，再按员工编号升序 SELECT * FROM employees ORDER BY salary DESC, employee_id ASC ; 按别名排序查询：查询员工信息，要求按员工年薪升序 SELECT *, salary * 12 * (1+ IFNULL(commission_pct, 0)) 年薪 FROM employees ORDER BY 年薪 ASC ; 按函数排序查询：查询员工信息，要求按员工名字的长度降序 SELECT LENGTH(last_name), last_name FROM employees ORDER BY LENGTH(last_name) DESC ; 按表达式排序：查询员工信息，要求按员工年薪升序 SELECT *, salary * 12 * (1+ IFNULL(commission_pct, 0)) FROM employees ORDER BY salary * 12 * (1+ IFNULL(commission_pct, 0)) ASC ; 四、字符串函数 SELECT 函数名(实参列表) 【FROM 表】; concat 连接字符 SELECT CONCAT('Hello',' ','World') AS out_put; substr 截取子串 截取从指定索引处后面所有字符 SELECT SUBSTR('李莫愁爱上了陆展元',7) AS out_put; 截取从指定索引处指定字符长度的字符 SELECT SUBSTR('李莫愁爱上了陆展元',1,3) AS out_put; replace 替换字符 SELECT REPLACE('张无忌爱上了周芷若','周芷若','赵敏') AS out_put; upper 变大写 SELECT UPPER('john') AS out_put; lower 变小写 SELECT LOWER('john') AS out_put; lpad 左填充 SELECT LPAD('殷素素',10,'*') AS out_put; rpad 右填充 SELECT LPAD('殷素素',10,'*') AS out_put; length 获取字节长度 SELECT LENGTH('john') AS out_put; trim 去除前后空格 删除指定字符的左右空格 SELECT LENGTH(TRIM(' 张翠山 ')) AS out_put; 删除指定字符的指定字符 SELECT TRIM('aaa' FROM 'aaaaaaaaa张翠山aaaaaaaaa') AS out_put; instr 获取子串第一次出现的索引 SELECT INSTR('杨不悔爱上了殷六侠','殷六侠') AS out_put; 返回子串第一次出现的索引，如果找不到返回0 五、 数学函数 round 四舍五入 默认四舍五入 SELECT ROUND(-1.55) AS out_put; 指定小数位数 SELECT ROUND(1.567,2) AS out_put; 四舍五入和符号无关 ceil 向上取整 SELECT CEIL(-1.02) AS out_put; 向上取整，返回>=该参数的最小整数 floor 向下取整 SELECT FLOOR(-9.99) AS out_put; 向下取整，返回 mod 取模运算（a-a/b*b） SELECT MOD(10,3) AS out_put truncate 保留小数的位数，不进行四舍五入 SELECT TRUNCATE(1.69999,1) AS out_pu rand 获取随机数，返回0-1之间的小数 SELECT RAND() AS out_put 六、 日期函数 now 返回当前日期+时间 SELECT NOW() AS out_put; curdate 返回当前日期 SELECT CURDATE() AS out_put; curtime 返回当前时间 SELECT CURTIME() AS out_put; year 返回年 SELECT YEAR(NOW()) 年; month 返回月 SELECT MONTH(NOW()) 月; day 返回日 SELECT DAY(NOW()) 日; hour 小时 SELECT HOUR(NOW()) 时; minute 分钟 SELECT MINUTE(NOW()) 分; second 秒 SELECT SECOND(NOW()) 秒; monthname 以英文形式返回月 SELECT MONTHNAME(NOW()) 月名; datediff 返回两个日期相差的天数 SELECT DATEDIFF('1995-2-7','1995-2-6') AS out_put; date_format 将日期转换成字符 SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日') AS out_put; str_to_date 将字符转换成日期 格式符： %Y：四位的年份 %y：二位的年份 %m：二位的月份（01，02，...，12） %c：一位的月份（1，2，...，12） %d：日（01，02，...，31） %H：小时（24小时制） %h：小时（12小时制） %i：分钟（00，01，02，...，59） %s：秒（00，01，02，...，59） SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put; 七、 控制函数 if 判断函数 IF(条件表达式，表达式1，表达式2)： 如果条件表达式成立，返回表达式1，否则返回表达式2 SELECT IF(10 case 分支函数 case的格式一 CASE 变量或字段或表达式 WHEN 常量1 THEN 值1 WHEN 常量2 THEN 值2 ... ELSE 值n END ; 案例：查询员工的工资，要求 部门号=30，显示的工资为1.1倍 部门号=40，显示的工资为1.2倍 部门号=50，显示的工资为1.3倍 其它部门，显示的工资为原工资 SELECT salary 原始工资, department_id, CASE department_id WHEN 30 THEN salary * 1.1 WHEN 40 THEN salary * 1.2 WHEN 50 THEN salary * 1.3 ELSE salary END AS 新工资 FROM employees ; case的格式二 CASE WHEN 条件1 THEN 值1 WHEN 条件2 THEN 值2 ... ELSE 值n END 案例：查询员工的工资情况 如果工资>20000，显示A级别 如果工资>15000，显示B级别 如果工资>10000，显示C级别 否则，显示D级别 SELECT salary, CASE WHEN salary > 20000 THEN 'A' WHEN salary > 15000 THEN 'B' WHEN salary > 10000 THEN 'C' ELSE 'D' END AS 工资级别 FROM employees ; 八、 其它函数 version 当前数据库的版本 SELECT VERSION(); database 当前打开的数据库 SELECT DATABASE(); user 当前登录的用户 SELECT USER(); password(‘字符’) 返回该字符的密码形式 SELECT PASSWORD('123456'); md5(‘字符’) 返回该字符的md5加密形式 SELECT MD5('123456'); 九、分组函数 SELECT 函数名(实参列表) 【FROM 表】; 1、sum、avg一般用于处理数值型，max、min、count可以处理任何类型 2、以上分组函数都忽略null值 3、可以和distinct搭配实现去重的运算：select sum(distinct 字段) from 表; 4、一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是group by后的字段 - sum 求和 ```sql SELECT SUM(salary) FROM employees; avg 平均值 SELECT AVG(salary) FROM employees; max 最大值 SELECT MAX(salary) FROM employees; min 最小值 SELECT MIN(salary) FROM employees; count 计算个数 SELECT COUNT(salary) FROM employees; 十、分组查询 SELECT 查询列表 FROM 表 【where 筛选条件】 GROUP BY 分组的字段 【having 分组后的筛选】 【order BY 排序的字段】 ; 1、和分组函数一同查询的字段必须是group by后出现的字段 2、筛选分为两类：分组前筛选和分组后筛选 针对的表 语句位置 连接的关键字 分组前筛选 分组前的原始表 group by前 where 分组后筛选 分组后的结果集 group by后 having 3、分组可以按单个字段也可以按多个字段 4、分组可以搭配着排序使用 GROUP BY 分组的字段 查询每个工种的员工平均工资 SELECT AVG(salary), job_id FROM employees GROUP BY job_id ; 查询每个位置的员工部门个数 SELECT COUNT(*), location_id FROM departments GROUP BY location_id ; 查询有奖金的每个领导手下员工的平均工资 SELECT AVG(salary), manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id ; 查询哪个部门的员工个数>5 SELECT COUNT(*), department_id FROM employees GROUP BY department_id HAVING COUNT(*) > 5 ; 查询每个工种有奖金的员工的最高工资>6000的最高工资和公众编号，按最高工资升序 SELECT MAX(salary) m, job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING m > 6000 ORDER BY m ; 查询每个工种每个部门的最低工资并按最低工资降序 SELECT MIN(salary), job_id, department_id FROM employees GROUP BY job_id, department_id ORDER BY MIN(salary) DESC ; window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-dql-join.html":{"url":"mysql/mysql-dql-join.html","title":"1.2.4 DQL语言 关联查询","keywords":"","body":"DQL语言 其二 连接查询又称多表查询，当查询的字段来自于多个表时，就会用到连接查询 SELECT 查询列表 FROM 表1 别名1 【连接类型】 JOIN 表2 别名2 ON 连接条件 【where 分组前筛选条件】 【group BY 分组列表】 【having 分组后筛选条件】 【order BY 排序列表】 ; 一、内连接 inner 内连接：也称为等值连接，每个表中找出符合条件的共有记录 注释：inner join 就等于 join 内连接：等值连接 查询员工名和对应的部门名 SELECT last_name, department_name FROM departments d INNER JOIN employees e ON e.`department_id` = d.`department_id`; 内连接：非等值连接 查询员工的工资和工资级别 SELECT salary, grade_level FROM employees e INNER JOIN job_grades g ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 内连接：自连接 查询员工名和它对应上级的名称 SELECT e.last_name, m.last_name FROM employees e INNER JOIN employees m ON e.`manager_id` = m.`employee_id`; 内连接: 其它写法 第一种写法：（只使用where） SELECT t.teacher_name, s.student_name FROM teacher t, student s WHERE t.id = s.teacher_id; 第二种写法：（join .. on.. ） SELECT t.teacher_name, s.student_name FROM teacher t JOIN student s ON t.id = s.teacher_id; 第三种写法：（inner join .. on.. ） SELECT t.teacher_name, s.student_name FROM teacher t INNER JOIN student s ON t.id = s.teacher_id; 二、外连接 左外连接：left 【outer】 （左边的是主表） 取左边的表的全部，右边的表按条件，符合的显示，不符合则显示null select from A left join B on A.id=B.id 查询哪个部门没有员工 SELECT d.`department_name` FROM departments d LEFT OUTER JOIN employees e ON d.`department_id` = e.`department_id` WHERE e.`employee_id` IS NULL; 右外连接：right 【outer】 （右边的是主表） 取右边的表的全部，左边的表按条件，符合的显示，不符合则显示null select from A right join B on A.id=B.id 查询哪个部门没有员工 SELECT d.`department_name` FROM employees e RIGHT OUTER JOIN departments d ON d.`department_id` = e.`department_id` WHERE e.`employee_id` IS NULL; 三、交叉连接(笛卡尔积 )：cross 交叉连接 返回左表中的所有行，左表中的每一行与右表中的所有行组合。 笛卡尔乘积是指在数学中，两个集合x和y的笛卡尓积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 举例：有两个集合A和B, A = {0,1} B = {2,3,4} 集合 A×B 和 B×A的结果集就可以分别表示为以下这种形式： A×B = {（0，2），（0，3），（0，4），（1，2），（1，3），（1，4）}； B×A = {（2，0），（2，1），（3，0），（3，1），（4，0），（4，1）}； 以上A×B和B×A的结果就可以叫做两个集合相乘的‘笛卡尔积’。 从以上的数据分析我们可以得出以下两点结论： 1，两个集合相乘，不满足交换率，既 A×B ≠ B×A; 2，A集合和B集合相乘，包含了集合A中元素和集合B中元素相结合的所有的可能性。 既两个集合相乘得到的新集合的元素个数是 A集合的元素个数 × B集合的元素个数; 交叉连接有两种，显式的和隐式的，不带ON子句，返回的是两表的乘积，也叫笛卡尔积。 例如：下面的语句1和语句2的结果是相同的。 语句1：隐式的交叉连接，没有CROSS JOIN SELECT O.ID, O.ORDER_NUMBER, C.ID, C.NAME FROM ORDERS O, CUSTOMERS C WHERE O.ID=1; 语句2：显式的交叉连接，使用CROSS JOIN。 SELECT O.ID, O.ORDER_NUMBER, C.ID, C.NAME FROM ORDERS O CROSS JOIN CUSTOMERS C WHERE O.ID=1; 使用交叉连接进行笛卡尔乘积查询 SELECT b.*, bo.* FROM beauty b CROSS JOIN boys bo ; 四、内连接和where的区别 数据库表连接数据行匹配时所遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。 笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行 比如现在数据库中有两张表，student表和 student_subject表，如下所示： 我们执行以下的sql语句，只是纯粹的进行表连接。 SELECT * from student JOIN student_subject; SELECT * from student_subject JOIN student; 从执行结果上来看，结果符合我们以上提出的两点结论（红线标注部分）； 以第一条sql语句为例我们来看一下他的执行流程， from语句把student表 和 student_subject表从数据库文件加载到内存中 join语句相当于对两张表做了乘法运算，把student表中的每一行记录按照顺序和student_subject表中记录依次匹配 匹配完成后，我们得到了一张有 （student中记录数 × student_subject表中记录数）条的临时表。 在内存中形成的临时表如表1.0所示。我们又把内存中表1.0所示的表称为笛卡尔积表。　　 再看一下sql中主要关键字的执行顺序： from on join where group by having select distinct union order by 我们看到on是在join和where前面的 ​ 如果两张表的数据量都比较大的话，那样就会占用很大的内存空间这显然是不合理的。所以，我们在进行表连接查询的时候一般都会使用JOIN xxx ON xxx的语法，ON语句的执行是在JOIN语句之前的，也就是说两张表数据行之间进行匹配的时候，会先判断数据行是否符合ON语句后面的条件，再决定是否JOIN。 　　因此，有一个显而易见的SQL优化的方案是，当两张表的数据量比较大，又需要连接查询时，应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。 参考文档 https://blog.csdn.net/wcc27857285/article/details/86439313 https://blog.csdn.net/qq_38490457/article/details/107640904 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-dql-son.html":{"url":"mysql/mysql-dql-son.html","title":"1.2.5 DQL语言 联合分页","keywords":"","body":"DQL语言 子查询 一、子查询 嵌套在其它语句内部的select语句称为子查询或内查询，外面的语句可以是insert、delete、update、select等，一般select作为外面语句较多，外面如果为select语句，则此语句称为外查询或主查询 - 子查询放在小括号内 - 子查询一般放在条件的右侧 - 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 - 标量子查询，一般搭配着单行操作符使用：>、>=、、=、 - 列子查询，一般搭配着多行操作符使用：in、not in、any、some、all、exits 1.1 select 后面：标量子查询 结果集为一行一列 查询每个部门的员工个数 SELECT d.*, ( SELECT COUNT( * ) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM departments d; 1.2 from 后面：表子查询 结果集为多行多列 查询每个部门平均工资的工资等级 SELECT ag_dep.*, g.`grade_level` FROM ( SELECT AVG( salary ) ag, department_id FROM employees GROUP BY department_id ) ag_dep INNER JOIN job_grades g ON ag_dep.ag BETWEEN lowest_sal AND highest_sal; 1.3 where 或 having后面 标量子查询：结果集为一行一列 查询最低工资的员工姓名和工资 SELECT last_name, salary FROM employees WHERE salary = ( SELECT MIN( salary ) FROM employees ); 列子查询：结果集为多行一列 查询所有是领导的员工姓名 SELECT last_name FROM employees WHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees ); 返回其它工种中比job_id为'IT_PROG'工种任一工资低的员工的员工号、姓名、job_id以及salary SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary 'IT_PROG'; 返回其它部门中比job_id为'IT_PROG'部门所有工资都低的员工的员工号、姓名、job_id以及salary SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary 'IT_PROG'; 返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary 'IT_PROG'; 行子查询：结果集为多行多列 查询员工编号最小并且工资最高的员工信息 SELECT * FROM employees WHERE (employee_id, salary) = (SELECT MIN( employee_id ), MAX( salary ) FROM employees); 1.4 exists 后面 查询有员工的部门名 SELECT department_name FROM departments d WHERE EXISTS ( SELECT * FROM employees e WHERE e.`department_id` = d.`department_id` ); 二、分页查询 SELECT 查询列表 FROM 表1 别名1 【连接类型】 JOIN 表2 别名2 ON 连接条件 【WHERE 分组前的筛选】 【GROUP BY 分组字段】 【HAVING 分组后的筛选 】 【ORDER BY 排序字段 ASC|DESC】 LIMIT 【offset, 】size ; 2.1 limit m; 从第0个查询， 向后推m个 从第0个查询， 向后推5个 Select * from sys_user limit 5; 返回数据 id 0 ---- 5 的数据 2.2 limit m, n; 从第m个查询， 向后推n个 从第5个查询， 向后推10 Select * from sys_user limit 5 , 10 返回数据 id 6 ----15 的数据 2.3 limit m offset n ; limit (向后推的m数) offset (从第n条开始) offset代表起始索引，起始索引从0开始，size代表条目个数 从第10个开始查询， 向后查询5个 Select * from sys_user limit 5 offset 10; 返回id 11---15 的数据 2.4 分页语句：select 查询列表 from 表 limit (page-1)*size, size; 三、联合查询 查询语句1 union 【all】 查询语句2 union 【all】 ... 要查询的结果来自于多个表且多个表没有直接的连接关系，但查询的信息一致时，可以使用联合查询 要求多条查询语句的查询列数是一致的 要求多条查询语句的查询的每一列的类型和顺序最好一致 union关键字默认去重，如果使用union all可以包含重复项 查询中国用户中男性的信息以及外国用户中年男性的用户信息 SELECT id, cname FROM t_ca WHERE csex='男' UNION ALL SELECT t_id, tname FROM t_ua WHERE tGender='male'; window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-ddl.html":{"url":"mysql/mysql-ddl.html","title":"1.2.6 DDL语言 库表管理","keywords":"","body":"第五章 DDL语言 一、数据库的管理 1. 库的创建 CREATE DATABASE 【IF NOT EXISTS】 库名 【 CHARACTER SET 字符集名】; 5.1.2、库的修改 修改库字符集 ALTER DATABASE 库名 CHARACTER SET 字符集名; 5.1.3、库的删除 DROP DATABASE 【IF EXISTS】 库名; 二、表的管理 5.2.1、表的创建 CREATE TABLE 【IF NOT EXISTS】 表名 ( 字段名 字段类型 【约束】, 字段名 字段类型 【约束】, ... 字段名 字段类型 【约束】 ) ; 5.2.2、表的修改 添加列 ALTER TABLE 表名 ADD COLUMN 列名 类型 【FIRST|AFTER 字段名】; 修改列的类型或约束 ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】; 修改列名 ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 类型; 删除列 ALTER TABLE 表名 DROP COLUMN 列名; 修改表名 ALTER TABLE 表名 RENAME 【TO】 新表名; 5.2.3、表的删除 方式一： DROP TABLE 【IF EXISTS】 表名; 方式二： TRUNCATE TABLE 【IF EXISTS】 表名; 5.2.4、表的复制 复制表的结构 CREATE TABLE 表名 LIKE 旧表; 复制表的某些字段 CREATE TABLE 表名 SELECT 字段1, 字段2,... FROM 旧表 WHERE 0; 复制表的结构+数据 CREATE TABLE 表名 SELECT 查询列表 FROM 旧表 【WHERE 筛选条件】; 复制表的某些字段+数据 CREATE TABLE 表名 SELECT 字段1,字段2,... FROM 旧表 【WHERE 筛选条件】; 三、数据类型 数值型 数值型 TINYINT SMALLINT MEDIUMINT INT/INTEGER BIGINT 字节 1 2 3 4 8 都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号 如果对数据没有特殊要求，则优先考虑使用INT/INTEGER 字符型 类型 CHAR VARCHAR BINARY VARBINARY ENUM SET TEXT BLOB 描述 固定长度字符 可变长度字符 二进制字符串 二进制字符串 枚举 集合 文本 二进制大型对象 char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1 varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略 如果对数据没有特殊要求，则优先考虑使用VARCHAR 浮点型 类型 TINYINT SMALLINT 定点数 DEC(M,D) ：M+2字节 DECIMAL(M,D)：M+2字节 浮点数 FLOAT(M,D) ：4字节 DOUBLE(M,D)：8字节 M代表整数部位+小数部位的个数，D代表小数部位 M和D都可以省略，但对于定点数，M默认为10，D默认为0 如果精度要求较高，则优先考虑使用定点数 日期型 类型 YEAR DATE TIME DATETIME TIMESTAMP 描述 年份 日期 时间 日期+时间 日期+时间 TIMESTAMP比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间 DATETIME只能反映出插入时的当地时区 如果对数据没有特殊要求，则优先考虑使用DATETIME 5.4、常见约束 1. 含义与分类 约束是一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 NOT NULL：非空，该字段的值必填 UNIQUE：唯一，该字段的值不可重复 DEFAULT：默认，该字段的值不用手动插入有默认值 CHECK：检查，MySQL不支持 PRIMARY KEY：主键，该字段的值不可重复并且非空 unique+not null FOREIGN KEY：外键，该字段的值引用了另外的表的字段 2. 创建表时添加约束 CREATE TABLE 表名( 字段名 字段类型 NOT NULL,#非空 字段名 字段类型 DEFAULT 值,#默认 字段名 字段类型 PRIMARY KEY,#主键 字段名 字段类型 UNIQUE,#唯一 CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表(被引用列) ) ; 3. 修改表时添加或删除约束 添加非空（列级约束） ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 NOT NULL; 删除非空 ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型; 添加默认（列级约束） ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 DEFAULT 值; 删除默认 ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型; 添加主键（列级约束） ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 PRIMARY KEY; 添加主键（表级约束） ALTER TABLE 表名 add 【CONSTRAINT 约束名】 PRIMARY KEY(字段名); 删除主键 ALTER TABLE 表名 DROP PRIMARY KEY; 添加唯一（列级约束） ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 UNIQUE; 添加唯一（表级约束） ALTER TABLE 表名 add 【CONSTRAINT 约束名】 UNIQUE(字段名); 删除唯一 ALTER TABLE 表名 DROP INDEX 索引名; 5.5、自增长列 创建表时添加自增长列 CREATE TABLE 表名 ( 字段名 字段类型 约束 AUTO_INCREMENT ) ; 修改表时添加自增长列 ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束 AUTO_INCREMENT; 修改表时删除自增长列 ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束; 数据的三范式 第一范式： 任何一张表都应该有主键，并且每个字段原子性不可再分 第二范式：建议在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖 多对多（学生表， 教师表，学生教师关系表） 第三范式：建议在第二范式基础上，所有非主键字段直接依赖主键，不能产生部分依赖(传递依赖) 学生表 id name class_id [class_name]这个端依赖class_id,传递依赖 班级表 id class_name 注：以冗余换速度 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-dcl.html":{"url":"mysql/mysql-dcl.html","title":"1.2.7 DCL语言 权限管理","keywords":"","body":"第六章 DCL语言 6.1、创建用户 CREATE USER '用户名'@'IP地址' IDENTIFIED BY '密码'; create user 'zhangsan’@'192.168.11111' identifyed by '123456'; create user 'zhangsan’@'192.168.%' identifyed by '123456; create user 'zhangsan’@'%' identifyed by '123456'; 注意：'IP地址'可以设置为localhost(代表本机)或者'%'(代表允许所有IP地址登录) 6.2、删除用户 DROP USER 用户名@'IP地址'; DROP USER 'zhangsan'@'localhost' 注意：'IP地址'可以设置为localhost(代表本机)或者'%'(代表允许所有IP地址登录) 6.3、用户授权 GRANT 权限1,权限2,...... ON 数据库名.* TO 用户名@'IP地址' IDENTIFIED BY '密码'; grant + 权限 + on + 数据库名.数据表明 + to '用户名'; 把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户。 grant all privileges on *.* to root@'%'identified by 'password'; grant select, insert,update on bookdb.book to 'zhangsan'; grant all privleges on bookdb.book to 'zhangsan'; 注意：所有的数据库就用*.*，所有的权限就用all或者all privileges 6.4、撤销授权 REVOKE 权限1,权限2,...... ON 数据库名.* FROM 用户名@'IP地址' IDENTIFIED BY '密码'; revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%'; 注意：所有的数据库就用*.*，所有的权限就用all或者all privileges 6.5、刷新授权 FLUSH PRIVILEGES; 6.6、查看授权 SHOW GRANTS FOR 用户名@'IP地址'; SHOW GRANTS FOR 'Simeon'@'%'; 注意：'IP地址'可以设置为localhost(代表本机)或者'%'(代表允许所有IP地址登录) 6.7、修改密码 修改密码 1. SET PASSWORD = PASSWORD('123456'); 2. UPDATE USER SET PASSWORD=PASSWORD('456') WHERE USER='zhangsan' 3. SET PASSWORD FOR 'zhangsan'@'localhost'=PASSWORD('456') 登录授权 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456'; 刷新授权 FLUSH PRIVILEGES; 6.8、修改密码复杂度 查看mysql默认密码复杂度 SHOW VARIABLES LIKE 'validate_password%'; 修改密码复杂度参考 set global validate_password_policy=LOW; // 验证密码长度 set global validate_password_length=6; // 设置密码长度 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-tcl.html":{"url":"mysql/mysql-tcl.html","title":"1.2.8 TCL语言 事务并发","keywords":"","body":"第七章 TCL语言 7.1、事务 一、含义 一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行 二、特点（ACID） 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行 一致性：一个事务的执行不能破坏数据库数据的完整性和一致性 隔离性：一个事务不受其它事务的干扰，多个事务是互相隔离的 持久性：一个事务一旦提交了，则永久的持久化到本地 三、分类 隐式事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete 显式事务：具有明显的开启和结束, 例如以下格式： 开启事务 set autocommit=0; 关闭自动提交 start transaction; 开启事务机制 编写一组逻辑sql语句 sql语句支持的是insert、update、delete 【设置回滚点，可选项】 savepoint 回滚点名; 结束事务 提交：commit; 回滚：rollback; 回滚到指定的地方： rollback to 回滚点名; 7.2、事务并发（读问题） 一、事物的并发问题如何发生？ 多个事务同时操作同一个数据库的相同数据时 二、事务的并发问题都有哪些？ 脏读：一个事务读到了另一个事务还未提交的update数据，导致多次查询的结果不一样 不可重复读：一个事务读到了另一个事务已经提交的update数据，导致多次查询结果不一致 幻读：一个事务读到了另一个事务已经提交的insert数据，导致多次查询的结果不一样 三、事物的并发问题如何解决？ 通过设置隔离级别来解决并发问题 四、隔离级别 隔离级别 隔离描述 脏读 不可重复读 幻读 READ UNCOMMITTED 读未提交 × × × READ COMMITTED 读已提交 √ × × REPEATABLE READ 可重复读 √ √ × SERIALIZABLE 串行化 √ √ √ 五、注意问题 mysql 中默认第三个隔离级别 REPEATABLE READ oracle 中默认第二个隔离级别 READ COMMITTED 查看隔离级别 SELECT @@tx_isolation; 设置隔离级别 SET SESSION|GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别; 7.3、丢失更新（写问题） 一、定义 在事务的隔离级别内容中，能够了解到两个不同的事务在并发的时候可能会发生数据的影响。细心的话可以发现事务隔离级别章节中，脏读、不可重复读、幻读三个问题都是由事务A对数据进行修改、增加，事务B总是在做读操作。如果两事务都在对数据进行修改则会导致另外的问题：丢失更新。 二、解决 悲观锁：认为两个事务更新操作一定会发生丢失更新 解决：通过在语句后边添加for update来实现行级上锁，所以又称为“行级锁” 例如：select * from t_account t wheret.id=‘1’ for update; 乐观锁：认为事务不一定会产生丢失更新，让事务进行并发修改，不对事务进行锁定 解决：由程序员自己解决，可以通过给数据表添加自增的version字段或时间戳timestamp，进行数据修改时，数据库会检测version字段或者时间戳是否与原来的一致，若不一致，抛出异常或者重新查询 三、注意 对于 账户交易建议直接使用悲观锁，数据库的性能很高，并发度不是很高的场景两者性能没有太大差别。如果是 交易减库存的操作可以考虑乐观锁，保证并发度。 事务补充与解读 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。 也就是事务具有原子性, 一个事务中的一系列的操作要么全部成功，要么一个都不做。 原子性 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。 如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 隔离性 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性 指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 数据库系统必须维护事务的以下特性 ： 原子性 、一致性 、隔离性 、持久性 事务中的所有操作要么全部执行，要么都不执行； 如果事务没有原子性的保证，那么在发生系统 故障的情况下，数据库就有可能处于不一致状态。 事务的结束有两种:1.当事务中的所以步骤全部成功执行时，事务提交。2.如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。 举个例子： A想要从自己的帐户中转3000块钱到B的帐户里。那个从A开始转帐，到转帐结束的这一个过程，称之为一个事务。在这个事务里，要做如下操作： 从A的帐户中减去3000块钱。如果A的帐户原来有3000块钱，现在就变成0块钱了。 在B的帐户里加3000块钱。如果B的帐户如果原来有0块钱，现在则变成3000块钱了。 如果在A的帐户已经减去了3000块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时B的帐户里还没有增加3000块钱。那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到A的帐户还没减3000块的状态，B的帐户的原来的状态。此时A的帐户仍然有3000块，B的帐户仍然有0块。（一致性） 我们把这种要么一起成功（A帐户成功减少3000，同时B帐户成功增加3000），要么一起失败（A帐户回到原来状态，B帐户也回到原来状态）的操作叫原子性操作。 如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-index.html":{"url":"mysql/mysql-index.html","title":"1.2.9 性能优化 索引部分","keywords":"","body":"第八章 索引创建 8.1、索引 一、含义 ​ 索引（index）是帮助MySQL高效获取数据的一种有序的数据结构 二、特点 - 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本 - 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 - 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的 - 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。 因为更新表时，MySQL 不仅要保存数据， 还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息 三、语法 创建 CREATE 【 UNIQUE|FULLTEXT|SPATIAL 】 INDEX 索引名称 ON 表名(字段列表); 修改 先删除，在创建 删除DROP INDEX 索引名称 ON 表名; 查看SHOW INDEX FROM 表名; alter命令 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL ALTER TABLE 表名 ADD PRIMARY KEY(字段列表); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次） ALTER TABLE 表名 ADD UNIQUE 索引名称(字段列表); 添加普通索引，索引值可以出现多次。 ALTER TABLE 表名 ADD INDEX 索引名称(字段列表); 该语句指定了索引为FULLTEXT，用于全文索引 ALTER TABLE 表名 ADD FULLTEXT 索引名称(字段列表); 1234567891011 四、注意 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引： 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价 对查询频次较高，且数据量比较大的表建立索引 使用唯一索引，区分度越高，使用索引的效率越高 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率 使用组合索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。例如：CREATE INDEX idx_name_email_status ON tb_seller(name,email,status); 就相当于对name 创建索引；对name , email 创建了索引；对name , email, status 创建了索引 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-master-slave.html":{"url":"mysql/mysql-master-slave.html","title":"1.2.10 性能优化 索引部分","keywords":"","body":"2.主从复制 一、为什么要主从复制 - 单点故障，压力大奔溃 - 服务器磁盘损坏 - 主从格式，一主多从，双主双从 三、主从复制原理 当master主服务器上的数据发生改变时，则将其改变写入二进制事件日志文件中 slave从服务器会在一定时间间隔内对master主服务器上的二进制日志文件进行探测，探测其是否发生过改变，如果探测到master主服务器的日志文件发生改变，则开始一个I/O Thread 请求 master二进制事件日志 同时master主服务器为每个I/O Thread 启动一个dump Thread， 用于想起发送二进制事件日志 slave 从服务器将接收到的二进制日志文件保存至自己本地的中继日志文件中 slave 从服务器将启动SQL Thread 从中继日志中读取二进制日志，在本地播放，使得其数据和主服务器保持一致 最后I/O Thread 和SQL Thread 将进入睡眠状态，等待下一次被唤醒 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-compare-one.html":{"url":"mysql/mysql-compare-one.html","title":"1.2.11 DQL高级  同比环比","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-compare-two.html":{"url":"mysql/mysql-compare-two.html","title":"1.2.12 DQL高级  同比环比","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/mysql-backup-recovery.html":{"url":"mysql/mysql-backup-recovery.html","title":"1.2.13 备份恢复 导入导出","keywords":"","body":"第九章 数据备份与恢复 9.1、数据导出 命令行下具体用法如下： mysqldump -u用戶名 -p密码 -d 数据库名 表名 > 文件保存路径; 导出整个数据库结构和数据 mysqldump -h localhost -uroot -p123456 database > dump.sql 导出单个数据表结构和数据 mysqldump -h localhost -uroot -p123456 database table > dump.sql 导出整个数据库结构（不包含数据） mysqldump -h localhost -uroot -p123456 -d database > dump.sql 导出单个数据表结构（不包含数据） mysqldump -h localhost -uroot -p123456 -d database table > dump.sql 导出查询结果 mysqldump -u用户名 -p -c --default-character-set=字符集 数据库名 数据表 --where=\"查询条件\" > 保存路径和文件名 导入查询结果：mysql -u用户名 -p -c --default-character-set=字符集 数据库名 9.2、数据导入 导入某张数据表 格式：mysql -u账户 -p密码 use 数据库名; source 文件保存路径 mysql -uroot -p123456 use test; source D:/emp.sql 导入整个数据库 格式：mysql -u账户 -p密码 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/pymysql-base.html":{"url":"mysql/pymysql-base.html","title":"1.3.1 pymysql 基本操作","keywords":"","body":"1.3.1 MySQL之pymysql 安装pymysql pip install pymysql 创建连接对象 conn = pymysql.connect( * 参数host：连接的mysql主机，如果本机是'localhost' * 参数port：连接的mysql主机的端口，默认是3306 * 参数user：连接的用户名 * 参数password：连接的密码 * 参数database or db：数据库的名称 * 参数charset：通信采用的编码方式，推荐使用utf8 * 参数connect_timeout: 连接时引发异常之前的超时(default: 10, min: 1, max: 31536000) * 参数cursorclass 使用的自定义游标类 ) 连接对象操作说明: * 关闭连接 conn.close() * 提交数据 conn.commit() * 回滚数据 conn.rollback() 获取游标对象 获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。代码如下: # 调用连接对象的cursor()方法获取游标对象 cur =conn.cursor() 游标操作说明: 使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数 主要用于执行insert、update、delete、select等语句 fetchone()、fetchmany()、fetchall() 、区别与联系: 如果select本身取的时候有多条数据时： cur.fetchone()：将只取最上面的第一条结果，返回单个元组如('id','title')，然后多次使用cur.fetchone()，依次取得下一条结果，直到为空。 cur.fetchmany(size)：将只取最上面的size条结果，返回单个元组如('id','title')，然后多次使用cur.fetchmany()，依次取得下size条结果，直到为空。 cur.fetchall() :将返回所有结果，返回二维元组，如(('id','title'),('id','title')), 如果select本身取的时候只有一条数据时： cur.fetchone()：将只返回一条结果，返回单个元组如('id','title')。 cur.fetchmany(size)：也将返回所有结果，返回二维元组，如(('id','title'),) cur.fetchall() :也将返回所有结果，返回二维元组，如(('id','title'),), 如果select 没有结果 ： cur.fetchone() ：没有结果 则返回 None cur.fetchmany(size) ：没有结果 则返回 () cur.fetchall() ：没有结果 则返回 () 关闭游标: cur.close(),表示和数据库操作完成 简单示例 import pymysql from pymysql.cursors import DictCursor conn = pymysql.connect( host='localhost', port=3306, user='root', password='1qaz2wsx', database='leqiaosu', charset='utf8', cursorclass=DictCursor ) cursor = conn.cursor() sql = \"select * from user;\" row_count = cursor.execute(sql) print(\"SQL执行影响的行数%d\" % row_count) # 取出结果集中一行数据 print(cursor.fetchone()) # 取出结果集中指定的行数 print(cursor.fetchmany(3)) # 取出结果集中的所有数据 print(cursor.fetchall()) # 关闭游标 cursor.close() # 关闭连接 conn.close() window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/pymysql-aiomysql.html":{"url":"mysql/pymysql-aiomysql.html","title":"1.3.2 aiomysql 基本操作","keywords":"","body":"1.3.2 MySQL之 aiomysql 一、为什么使用aiomysql 一、为什么要使用连接池 mysql查询每次查询数据都会使用单独connection，使用一次以后就断开，再次使用再次连接 但是对于mysql，每次连接的开销都很高，遇到高并发高频率开销更高，所以使用连接池 mysql服务设置超时链接，比如8小时，如果一个连接8个小时都没有操作，mysql会主动的断开连接，当这个连接再次尝试查询的时候就会报错，所以使用连接池，保持可用链接 连接池: MySQL中保持着指定数量的可用连接，当一个查询结执行之前从这个池子里取一个连接，查询结束以后将连接放回池子中，这样可以避免频繁的连接数据库，节省大量的资源。 异步的操作的优势在于它可以”同时”的进行多个操作，如果查询只是一个一个的单独查询，那用不用异步其实都无所谓，这里尝试使用异步来同时执行多个操作 二、aiomysql aiomysql的文档 pip install aiomysql 三、简单示例 aiomysql.cursors.DeserializationCursor aiomysql.cursors.DictCursor 反序列化json类型数据 import asyncio import aiomysql async def test_example(loop): conn = await aiomysql.connect( host='127.0.0.1', port=3306, user='root', password='', db='mysql', loop=loop ) async with conn.cursor() as cur: await cur.execute(\"SELECT Host,User FROM user\") print(cur.description) r = await cur.fetchall() print(r) conn.close() loop = asyncio.get_event_loop() loop.run_until_complete(test_example(loop)) import asyncio import aiomysql async def test_example(loop): pool = await aiomysql.create_pool(host='127.0.0.1', port=3306, user='root', password='', db='mysql', loop=loop) async with pool.acquire() as conn: async with conn.cursor() as cur: await cur.execute(\"SELECT 42;\") print(cur.description) (r,) = await cur.fetchone() assert r == 42 pool.close() await pool.wait_closed() loop = asyncio.get_event_loop() loop.run_until_complete(test_example(loop)) 注: 更多示例参考 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/pymysql-dbutils.html":{"url":"mysql/pymysql-dbutils.html","title":"1.3.3 DBUtils 连接池","keywords":"","body":"1.3.2 MySQL之 DBUtils 一、为什么要使用连接池 mysql查询每次查询数据都会使用单独connection，使用一次以后就断开，再次使用再次连接 但是对于mysql，每次连接的开销都很高，遇到高并发高频率开销更高，所以使用连接池 mysql服务设置超时链接，比如8小时，如果一个连接8个小时都没有操作，mysql会主动的断开连接，当这个连接再次尝试查询的时候就会报错，所以使用连接池，保持可用链接 连接池: MySQL中保持着指定数量的可用连接，每次重新获取一个有效的连接进行查询操作 执行完查询语句以后要将connection关闭，注意这里的关闭并不是真正的关闭，而只是将连接返回给连接池让其它人使用 pymysql本身不具有连接池功能，需要借助DBUtils，DBUtils是一套Python数据库连接池包，并允许对非线程安全的数据库接口进行线程安全包装。 二、安装方法及优点 pip install DBUtils PooledDB ：提供线程间可共享的数据库连接，并自动管理连接。 SharedDBConnection创建一批连接，供所有线程共享使用 三、方法示例 实例化池对象，写入池的配置信息;创建一批连接放入连接池，共享使用 POOL = PooledDB() 池连接 conn = POOL.connection() 执行SQL语句 conn.cursor().execute('select * from user') 获取执行SQL后的返回 conn.cursor().fetchall() 未关闭连接，只是将连接放回池子，供所有线程共享使用；当线程终止时，连接自动关闭； conn.close() maxconnections: 接池允许的最大连接数,0和None表示没有限制(默认) mincache: 初始化时,连接池至少创建的空闲连接,0表示不创建 maxcached: 连接池中空闲的最多连接数,0和None表示没有限制 maxshared:连接池中最多共享的连接数量,0和None表示全部共享(其实没什么用) blocking: 连接池中如果没有可用共享连接后,是否阻塞等待,True表示等等,False表示不等待然后报错 setsession: 开始会话前执行的命令列表 ping: ping Mysql服务器检查服务是否可用 import pymysql from DBUtils.PooledDB import PooledDB POOL = PooledDB( creator=pymysql, # 使用链接数据库的模块 maxconnections=6, # 连接池允许的最大连接数，0和None表示不限制连接数 mincached=2, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=5, # 链接池中最多闲置的链接，0和None不限制 maxshared=3, # 链接池中最多共享的链接数量，0和None表示全部共享。 # PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少， # _maxcached永远为0，所以永远是所有链接都共享。 blocking=True, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=[], # 开始会话前执行的命令列表。 ping=0, # ping MySQL服务端，检查是否服务可用。 # 如：0 = None = never, # 1 = default = whenever it is requested, # 2 = when a cursor is created, # 4 = when a query is executed, # 7 = always host='127.0.0.1', port=3306, user='root', password='123456', database='test', charset='utf8' ) def func(): # 检测当前正在运行连接数的是否小于最大链接数，如果不小于则：等待或报raise TooManyConnections异常 # 否则 则优先去初始化时创建的链接中获取链接 SteadyDBConnection。 # 然后将SteadyDBConnection对象封装到PooledDedicatedDBConnection中并返回。 # 如果最开始创建的链接没有链接，则去创建一个SteadyDBConnection对象，再封装到PooledDedicatedDBConnection中并返回。 # 一旦关闭连接，其实并没有真正关闭，只是将连接返回给连接池 conn = POOL.connection() # print(th, '链接被拿走了', conn1._con) # print(th, '池子里目前有', pool._idle_cache, '\\r\\n') cursor = conn.cursor() cursor.execute('select * from user') result = cursor.fetchall() print(result) conn.close() connection.close() if __name__ == '__main__': func() 参考https://blog.csdn.net/weixin_40976261/article/details/89057633 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/pymysql-pool.html":{"url":"mysql/pymysql-pool.html","title":"1.3.4 DBUtils 高级用法","keywords":"","body":"1.3.3 MySQL之 DBUtils.PooledDB 使用dbutils的PooledDB连接池，操作数据库。 这样就不需要每次执行sql后都关闭数据库连接，频繁的创建连接，消耗时间 如果是使用一个连接一直不关闭，多线程下，插入超长字符串到数据库，运行一段时间后很容易出现OperationalError: (2006, ‘MySQL server has gone away’)这个错误。 示例一 MyDbUtils： #-*- coding: UTF-8 -*- import pymysql from DBUtils.PooledDB import PooledDB import DB_config as Config import MySQLdb ''' @功能：PT数据库连接池 ''' class PTConnectionPool(object): __pool = None; # def __init__(self): # self.conn = self.__getConn(); # self.cursor = self.conn.cursor(); def __enter__(self): self.conn = self.__getConn(); self.cursor = self.conn.cursor(); print u\"PT数据库创建con和cursor\"; return self; def __getConn(self): if self.__pool is None: self.__pool = PooledDB( creator=MySQLdb, mincached=Config.DB_MIN_CACHED , maxcached=Config.DB_MAX_CACHED, maxshared=Config.DB_MAX_SHARED, maxconnections=Config.DB_MAX_CONNECYIONS, blocking=Config.DB_BLOCKING, maxusage=Config.DB_MAX_USAGE, setsession=Config.DB_SET_SESSION, host=Config.DB_TEST_HOST , port=Config.DB_TEST_PORT , user=Config.DB_TEST_USER , passwd=Config.DB_TEST_PASSWORD , db=Config.DB_TEST_DBNAME , use_unicode=False, charset=Config.DB_CHARSET ); return self.__pool.connection() \"\"\" @summary: 释放连接池资源 \"\"\" def __exit__(self, type, value, trace): self.cursor.close() self.conn.close() print u\"PT连接池释放con和cursor\"; #重连接池中取出一个连接 def getconn(self): conn = self.__getConn(); cursor = conn.cursor(); return cursor,conn #关闭连接归还给连接池 # def close(self): # self.cursor.close() # self.conn.close() # print u\"PT连接池释放con和cursor\"; def getPTConnection(): return PTConnectionPool() 配置文件：DB_config.py #-*- coding: UTF-8 -*- #TEST数据库信息 DB_TEST_HOST=\"192.168.88.6\"; DB_TEST_PORT=3306; DB_TEST_DBNAME=\"asterisk\"; DB_TEST_USER=\"root\"; DB_TEST_PASSWORD=\"kalamodo\"; #数据库连接编码 DB_CHARSET=\"utf8\"; #mincached : 启动时开启的闲置连接数量(缺省值 0 开始时不创建连接) DB_MIN_CACHED=10; #maxcached : 连接池中允许的闲置的最多连接数量(缺省值 0 代表不闲置连接池大小) DB_MAX_CACHED=10; #maxshared : 共享连接数允许的最大数量(缺省值 0 代表所有连接都是专用的)如果达到了最大数量,被请求为共享的连接将会被共享使用 DB_MAX_SHARED=20; #maxconnecyions : 创建连接池的最大数量(缺省值 0 代表不限制) DB_MAX_CONNECYIONS=100; #blocking : 设置在连接池达到最大数量时的行为(缺省值 0 或 False 代表返回一个错误; 其他代表阻塞直到连接数减少,连接被分配) DB_BLOCKING=True; #maxusage : 单个连接的最大允许复用次数(缺省值 0 或 False 代表不限制的复用).当达到最大数时,连接会自动重新连接(关闭和重新打开) DB_MAX_USAGE=0; #setsession : 一个可选的SQL命令列表用于准备每个会话，如[\"set datestyle to german\", ...] DB_SET_SESSION=None; 封装的mysqlhelp.py import MySQLdb from MyDbUtils import getPTConnection class MysqlHelp(object): mysql=None def __init__(self): # self.connect() self.db=getPTConnection() def __new__(cls, *args, **kwargs): if not hasattr(cls, 'inst'): cls.inst = super(MysqlHelp, cls).__new__(cls, *args, **kwargs) return cls.inst #查询所有 def selectall(self,sql='',param=()): #判断是否连接,并设置重连机制 # self.connected() try: cursor,conn=self.execute(sql,param) res=cursor.fetchall() self.close(cursor, conn) return res except Exception,e: print 'selectall except ', e.args self.close(cursor, conn) return None #查询一条 def selectone(self,sql='',param=()): # self.connected() try: # cur = self.db.cursor() cursor, conn=self.execute(sql,param) res = cursor.fetchone() self.close(cursor, conn) return res except Exception, e: print 'selectone except ', e.args self.close(cursor, conn) return None #增加 def insert(self,sql='',param=()): # self.connected() try: # self.db.getconn().execute(sql, param) cursor, conn=self.execute(sql,param) print '============' # _id=self.db.conn.insert_id() _id=cursor.lastrowid print '_id ',_id conn.commit() self.close(cursor, conn) #防止表中没有id返回0 if _id==0: return True return _id except Exception, e: print 'insert except ', e.args conn.rollback() self.close(cursor, conn) # self.conn.rollback() return 0 #增加多行 def insertmany(self,sql='',param=()): # self.connected() cursor,conn=self.db.getconn() try: cursor.executemany(sql, param) # self.execute(sql,param) conn.commit() self.close(cursor, conn) return True except Exception, e: print 'insert many except ', e.args conn.rollback() self.close(cursor, conn) # self.conn.rollback() return False #删除 def delete(self,sql='',param=()): # self.connected() try: # cur = self.conn.cursor() # self.db.getconn().execute(sql, param) cursor,conn=self.execute(sql,param) # self.db.conn.commit() self.close(cursor, conn) return True except Exception, e: print 'delete except ', e.args conn.rollback() self.close(cursor, conn) # self.conn.rollback() return False #更新 def update(self,sql='',param=()): # self.connected() try: #cur = self.conn.cursor() # self.db.getconn().execute(sql, param) cursor,conn=self.execute(sql,param) # self.db.conn.commit() self.close(cursor, conn) return True except Exception, e: print 'update except ',e.args conn.rollback() self.close(cursor, conn) # self.conn.rollback() return False @classmethod def getInstance(self): if MysqlHelp.mysql==None: MysqlHelp.mysql=MysqlHelp() return MysqlHelp.mysql #执行命令 def execute(self,sql='',param=(),autoclose=False): cursor, conn = self.db.getconn() try: if param: cursor.execute(sql, param) else: cursor.execute(sql) conn.commit() if autoclose: self.close(cursor, conn) except Exception as e: pass return cursor, conn #执行多条命令 '[{\"sql\":\"xxx\",\"param\":\"xx\"}....]' def executemany(self,list=[]): cursor,conn=self.db.getconn() try: for order in list: sql=order['sql'] param=order['param'] if param: cursor.execute(sql,param) else: cursor.execute(sql) conn.commit() self.close(cursor, conn) return True except Exception as e: print 'execute failed========',e.args conn.rollback() self.close(cursor, conn) return False def connect(self): self.conn = MySQLdb.connect(user='root', db='asterisk', passwd='kalamodo', host='192.168.88.6') def close(self,cursor,conn): cursor.close() conn.close() print u\"PT连接池释放con和cursor\"; 示例二 # coding=utf-8 \"\"\" 使用DBUtils数据库连接池中的连接，操作数据库 OperationalError: (2006, ‘MySQL server has gone away’) \"\"\" import json import pymysql import datetime from DBUtils.PooledDB import PooledDB import pymysql class MysqlClient(object): __pool = None; def __init__(self, mincached=10, maxcached=20, maxshared=10, maxconnections=200, blocking=True, maxusage=100, setsession=None, reset=True, host='127.0.0.1', port=3306, db='test', user='root', passwd='123456', charset='utf8mb4' ): \"\"\" :param mincached:连接池中空闲连接的初始数量 :param maxcached:连接池中空闲连接的最大数量 :param maxshared:共享连接的最大数量 :param maxconnections:创建连接池的最大数量 :param blocking:超过最大连接数量时候的表现，为True等待连接数量下降，为false直接报错处理 :param maxusage:单个连接的最大重复使用次数 :param setsession:optional list of SQL commands that may serve to prepare the session, e.g. [\"set datestyle to ...\", \"set time zone ...\"] :param reset:how connections should be reset when returned to the pool (False or None to rollback transcations started with begin(), True to always issue a rollback for safety's sake) :param host:数据库ip地址 :param port:数据库端口 :param db:库名 :param user:用户名 :param passwd:密码 :param charset:字符编码 \"\"\" if not self.__pool: self.__class__.__pool = PooledDB( pymysql, mincached, maxcached, maxshared, maxconnections, blocking, maxusage, setsession, reset, host=host, port=port, db=db, user=user, passwd=passwd, charset=charset, cursorclass=pymysql.cursors.DictCursor ) self._conn = None self._cursor = None self.__get_conn() def __get_conn(self): self._conn = self.__pool.connection(); self._cursor = self._conn.cursor(); def close(self): try: self._cursor.close() self._conn.close() except Exception as e: print e def __execute(self, sql, param=()): count = self._cursor.execute(sql, param) print count return count @staticmethod def __dict_datetime_obj_to_str(result_dict): \"\"\"把字典里面的datatime对象转成字符串，使json转换不出错\"\"\" if result_dict: result_replace = {k: v.__str__() for k, v in result_dict.items() if isinstance(v, datetime.datetime)} result_dict.update(result_replace) return result_dict def select_one(self, sql, param=()): \"\"\"查询单个结果\"\"\" count = self.__execute(sql, param) result = self._cursor.fetchone() \"\"\":type result:dict\"\"\" result = self.__dict_datetime_obj_to_str(result) return count, result def select_many(self, sql, param=()): \"\"\" 查询多个结果 :param sql: qsl语句 :param param: sql参数 :return: 结果数量和查询结果集 \"\"\" count = self.__execute(sql, param) result = self._cursor.fetchall() \"\"\":type result:list\"\"\" [self.__dict_datetime_obj_to_str(row_dict) for row_dict in result] return count, result def execute(self, sql, param=()): count = self.__execute(sql, param) return count def begin(self): \"\"\"开启事务\"\"\" self._conn.autocommit(0) def end(self, option='commit'): \"\"\"结束事务\"\"\" if option == 'commit': self._conn.autocommit() else: self._conn.rollback() if __name__ == \"__main__\": mc = MysqlClient() sql1 = 'SELECT * FROM shiji WHERE id = 1' result1 = mc.select_one(sql1) print json.dumps(result1[1], ensure_ascii=False) sql2 = 'SELECT * FROM shiji WHERE id IN (%s,%s,%s)' param = (2, 3, 4) print json.dumps(mc.select_many(sql2, param)[1], ensure_ascii=False) 参考与转载 https://www.cnblogs.com/huay/p/11562094.html https://www.cnblogs.com/ydf0509/p/8972265.html https://blog.csdn.net/daerzei/article/details/83865325 https://blog.csdn.net/u010939285/article/details/71088145 https://blog.csdn.net/weixin_43064185/article/details/89928645 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-introduction.html":{"url":"mysql/peewee-introduction.html","title":"1.4 peewee","keywords":"","body":"1.3.1 MySQL之windows版本安装 1. 下载 MySQL-download 2. 解压到安装目录 本人解压到D:\\MySQL\\mysql-5.7.29-winx64 注：别虎不拉基的用中文命名 3. 配置文件 my.ini文件内容 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=D:\\\\MySQL\\\\mysql-5.7.29-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\\\MySQL\\\\mysql-5.7.29-winx64\\\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 4. 配置文件 变量名： MYSQL_HOME 变量值: D:\\MySQL\\mysql-5.7.29-winx64 path中添加: %MYSQL_HOME%\\bin 5. 初始化及相应配置 初始化命令mysqld --initialize --user=mysql --console 此处本人还报了错误：由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题 添加服务mysqld -install 启动服务net start mysql 登录数据库mysql -u root -p 密码为初始化密码(上上图) 修改密码：alter user 'root'@'localhost' identified with mysql_native_password by '1qaz2wsx'; 刷新：FLUSH PRIVILEGES; window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-model.html":{"url":"mysql/peewee-model.html","title":"1.4.1 model","keywords":"","body":"1.3.1 peewee-model 一、字段类型 字段类型 Sqlite Postgresql MySQL AutoField 自增 integer serial integer BigAutoField 自增 integer bigserial bigint IntegerField 整数 integer integer integer BigIntegerField integer bigint bigint SmallIntegerField integer smallint smallint IdentityField not supported int identity not supported FloatField 浮点型 real real real DoubleField 双精度 real double precision double precision DecimalField 小数 decimal numeric numeric CharField 字符 varchar varchar varchar FixedCharField char char char TextField 文本 text text text BlobField blob bytea blob BitField integer bigint bigint BigBitField blob bytea blob UUIDField uid text uuid varchar(40) BinaryUUIDField 二进制uuid blob bytea varbinary(16) DateTimeField 日期时间 datetime timestamp datetime DateField 日期 date date date TimeField 时间 time time time TimestampField 时间戳 integer integer integer IPField integer bigint bigint BooleanField 布尔 integer boolean bool BareField untyped not supported not supported ForeignKeyField 外键 integer integer integer 二、字段初始化参数(字段类型都接受的参数及其默认值) null = False –允许空值 index = False –在此列上创建索引 unique = False–在此列上创建唯一索引。另请参阅添加复合索引。 column_name = None –在数据库中明确指定列名称。 default = None –任何值或可调用以用作未初始化模型的默认值 primary_key = False –表的主键 constraints = None -一个或多个约束，例如 [Check('price > 0')] sequence = None –序列名称（如果后端支持） collation = None –用于排序字段/索引的排序规则 unindexed = False–指示虚拟表上的字段应未索引（仅SQLite） choices = None–可选的可迭代，包含2个元组value，display help_text = None –表示该字段任何有用文本的字符串 verbose_name = None –表示该字段“用户友好”名称的字符串 index_type = None–指定自定义索引类型，例如，对于Postgres，您可以指定一个'BRIN'或'GIN'索引。 三、一些字段带有特殊参数 CharField max_length FixedCharFieldmax_lengthDateTimeFieldformatsDateFieldformatsTimeFieldformats TimestampFieldresolution, utcDecimalFieldmax_digits, decimal_places,auto_round, roundingForeignKeyFieldmodel, field, backref,on_delete, on_update, deferrablelazy_loadBareFieldadapt 四、根据模型生成数据表 方法 database.create_tables([User, UserAuth]) 有其他的model往列表加即可 database.close() 12 方法 myModels = [User, UserAuth] for myModel in myModels: myModel.create_table() 五、根据数据表生成模型 如果不需要自己去创建表，已有现成的表可用，可以使用下面的命令生成模型 python -m pwiz -e mysql -H 127.0.0.1 -p 3306 -u root -P dbname >model.py python -m pwiz -e mysql -H {主机地址} -p 3306 -u root -- password {数据库名称} > {生成的代码文件 例model.py} 解释： 选项 解释 举例 -h help 显示帮助 -h -e engine 数据库引擎 -e mysql -H host 数据库地址 -H localhost -p port 数据库端口 -p 3306 -u user 数据库用户名 -u root -P password 数据库密码 -P -s schema 模式 -s public -t tables 指定生成来自表格 -t tweet,users,relationships -v VIEWs 指定生成来自视图 -v -i info 添加原信息 -i -o order 保留表格列顺序 -o -e数据库类型 比如mysql -H数据库ip -p端口 -u数据库用户名 -P密码 dbname为db名 db.py自动生成的py文件名 其它 from peewee import * from bcrypt import hashpw, gensalt from MxForm.models import BaseModel class PasswordHash(bytes): def check_password(self, password): password = password.encode('utf-8') return hashpw(password, self) == self class PasswordField(BlobField): def __init__(self, iterations=12, *args, **kwargs): if None in (hashpw, gensalt): raise ValueError('Missing library required for PasswordField: bcrypt') self.bcrypt_iterations = iterations self.raw_password = None super(PasswordField, self).__init__(*args, **kwargs) def db_value(self, value): \"\"\"Convert the python value for storage in the database.\"\"\" if isinstance(value, PasswordHash): return bytes(value) if isinstance(value, str): value = value.encode('utf-8') salt = gensalt(self.bcrypt_iterations) return value if value is None else hashpw(value, salt) def python_value(self, value): \"\"\"Convert the database value to a pythonic value.\"\"\" if isinstance(value, str): value = value.encode('utf-8') return PasswordHash(value) GENDERS = ( (\"female\", \"女\"), (\"male\", \"男\") ) class User(BaseModel): mobile = CharField(max_length=11, verbose_name=\"手机号码\", index=True, unique=True) password = PasswordField(verbose_name=\"密码\") #1. 密文，2.不可反解 nick_name = CharField(max_length=20, null=True, verbose_name=\"昵称\") head_url = CharField(max_length=200, null=True, verbose_name=\"头像\") address = CharField(max_length=200, null=True, verbose_name=\"地址\") desc = TextField(null=True, verbose_name=\"个人简介\") gender = CharField(max_length=200, choices=GENDERS, null=True, verbose_name=\"地址\") window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-connect.html":{"url":"mysql/peewee-connect.html","title":"1.4.2 connect","keywords":"","body":"1.3.2 peewee之connect peewee连接数据库根据场景目前总结常用的集中情况情况，可根据使用的场景自行选择连接方式。 from peewee import * 方法一 database = MySQLDatabase('database', host=\"\", user=\"\",passwd=\"\" ) database.connect() 方法二 使用数据库URL连接 from playhouse.db_url import connect database = connect('mysql://user:passwd@ip:port/my_db') 方法三 运行时数据库配置，这些值可能是从配置文件或环境中加载的 from peewee import * database = MySQLDatabase(None) class BaseModel(Model): class Meta: database = database database.init( database=self.conf['db_base'], host=self.conf['db_host'], port=self.conf.get('db_port', 3306), user=self.conf['db_user'], passwd=self.conf['db_passwd'], charset='utf8' ) 方法四 链接池（超时后，连接将被回收, 打开的连接数上限) from playhouse.pool import PooledMySQLDatabase db = PooledMySQLDatabase( 'my_database', max_connections=8, stale_timeout=300, user='user', password='password', host='127.0.0.0', port=3306 ) class BaseModel(Model): class Meta: database = db 方法五 [主从连接](https://pypi.org/project/pwmd/) from peewee import Model, CharField, DateField, BooleanField from pwmd import MultiMySQLDatabase DATABASE = { 'master': 'mysql://root@localhost/test_app', 'slaves': ['mysql://root@localhost/test_app'] } db = MultiMySQLDatabase(DATABASE) db.connect() class BaseModel(Model): class Meta: database = db class Person(BaseModel): name = CharField() birthday = DateField() is_relative = BooleanField() 方法六 运行时动态定义数据库 database_proxy = DatabaseProxy() # Create a proxy for our db. class BaseModel(Model): class Meta: database = database_proxy # Use proxy for our DB. class User(BaseModel): username = CharField() # Based on configuration, use a different database. if app.config['DEBUG']: database = SqliteDatabase('local.db') elif app.config['TESTING']: database = SqliteDatabase(':memory:') else: database = PostgresqlDatabase('mega_production_db') # Configure our proxy to use the db we specified in config. database_proxy.initialize(database) 运行数据库 db = SqliteDatabase('my_app.db', pragmas={'journal_mode': 'wal'}) # Specify the details at run-time: db = SqliteDatabase(None) db.init(db_filename, pragmas={'journal_mode': 'wal'}) # Or use a placeholder: db = DatabaseProxy() db.initialize(SqliteDatabase('my_app.db', pragmas={'journal_mode': 'wal'})) 方法七 数据库重连，连接池连接不够 - # *_ coding:utf-8 _*_ from playhouse.pool import PooledMySQLDatabase from playhouse.shortcuts import ReconnectMixin import config class RetryMySQLDatabase(ReconnectMixin, PooledMySQLDatabase): _instance = None @staticmethod def get_db_instance(): if not RetryMySQLDatabase._instance: RetryMySQLDatabase._instance = RetryMySQLDatabase( config.get('db_name', 'aaabb'), max_connections=8, stale_timeout=300, host=config.get('db_host', '127.0.0.1'), user=config.get('db_user', 'root'), password=config.get('db_pwd', '123'), port=config.get('db_port', 3306) ) return RetryMySQLDatabase._instance # 如何使用？ # 在model文件中 database = RetryMySQLDatabase.get_db_instance() 为了不用不停的连接断开peewee提供with 操作 with database.connection_context(): Person.select() .... 方法八 ssh访问数据库的实例 db.is_closed() # 判断数据库是不是链接 db.connect() # 数据库链接 db.create_tables([Person,]) #建库 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-insert.html":{"url":"mysql/peewee-insert.html","title":"1.4.3 insert","keywords":"","body":"1.3.3 peewee之insert peewee连接数据库根据场景目前总结常用的集中情况情况，可根据使用的场景自行选择连接方式。 model from peewee import * database = MySQLDatabase('leqiaosu', **{'charset': 'utf8', 'sql_mode': 'PIPES_AS_CONCAT', 'use_unicode': True, 'host': 'localhost', 'port': 3306, 'user': 'root', 'password': '1qaz2wsx'}) class UnknownField(object): def __init__(self, *_, **__): pass class BaseModel(Model): class Meta: database = database class User(BaseModel): username = CharField(verbose_name='姓名', max_length=10, null=False, index=True) email = CharField(verbose_name='邮件', max_length=50, null=True, unique=True) gender = IntegerField(verbose_name='姓别', null=False, default=1) score = IntegerField(constraints=[SQL(\"DEFAULT 0\")]) birthday = DateField(verbose_name='生日', null=True, default=None) is_admin = BooleanField(verbose_name='是否是管理员', default=True) gmt_created = DateTimeField(constraints=[SQL(\"DEFAULT CURRENT_TIMESTAMP\")]) gmt_modified = DateTimeField(constraints=[SQL(\"DEFAULT CURRENT_TIMESTAMP\")]) class Meta: table_name = 'user' # 这里可以自定义表名 一、执行原生SQL cursor()方法 user = User() cursor = user.cursor() cursor.execute('SELECT `id`, `uname`, `gender` FROM `user` WHERE `id`=1') for (id, uname, gender) in cursor: print('%d:%s:%s' % (id, username, gender)) executemany() user = User() cursor = user.cursor() data_source = [ (\"zhangsan\", 65, 2), (\"lisi\", 71, 1) ] cursor.executemany('insert into `user`(`username`, `score`, `gender`) values (%s, %s, %s) ', data_source) # 返回插入条数 user.commit() cursor.close() 执行原生SQL temp = User.raw('select * from user').dicts() query = User.raw('SELECT * FROM my_table WHERE data = %s', user_data) query = User.select().where(SQL('Some SQL expression %s' % user_data)) 二、单条增加 create 返回值插入idUser.create(username='python', score=99, gender=1) insert 返回值插入id User.insert(username='lisi', score=97, gender=1).execute() 等同于insert into User (user_name, score, gender) values ('lisi', 97, 1) 构造一个key: value 的字典，返回值插入iddata = {'username': \"zhangsan\", \"score\": 98, \"gender\": 1} User.create(**data) save 调用save()方法之后，数据会被插入到数据库中，返回此操作影响的数据数量 user = User(username='wanger', score=95, gender=2) user .save() 如果要更新数据，直接修改实例属性值即可： user.score = 99 user.save() 三、多条增加 for循环和Model.create()（最慢） data_source = [ {'username': \"zhaoda\", \"score\": 59, \"gender\": 1}, {'username': \"qianer\", \"score\": 67, \"gender\": 2}, {'username': \"sunsan\", \"score\": 458, \"gender\": 0} ] for data_dict in data_source: User.create(**data_dict) for循环和Model.create()，并放入事务中（较快） data_source = [ {'username': \"zhouqi\", \"score\": 59, \"gender\": 1}, {'username': \"wuba\", \"score\": 67, \"gender\": 2}, {'username': \"fengjiu\", \"score\": 89, \"gender\": 0} ] with database.atomic(): for data_dict in data_source: User.create(**data_dict) 使用原生的insert_many()，并放入事务中（最快） insert_many(rows, fields=None) rows：元组或字典列表，要插入的数据 fields(list)：需要插入的字段名（可传可不传，如传列表rows 中的字段在字典中必须存在 data_source = [ {'username': \"chen\", \"score\": 59, \"gender\": 1}, {'username': \"chu\", \"score\": 87, \"gender\": 2}, {'username': \"wei\", \"score\": 39, \"gender\": 0} ] # User.insert_many(data_source).execute() with database.atomic(): User.insert_many(data_source).execute() 如果数据量太大或许你需要分开处理，比如一次处理100条： data_source = [ {'username': \"chen\", \"score\": 59, \"gender\": 1}, {'username': \"chu\", \"score\": 87, \"gender\": 2}, {'username': \"wei\", \"score\": 39, \"gender\": 0} ] with database.atomic(): for idx in range(0,len(data_source),100): User.insert_many(data_source[idx:idx+100]).execute() Peewee分块辅助函数 chunked()，使用它可以有效地将通用迭代块分块为一系列批量迭代的迭代： from peewee import chunked with db.atomic(): for batch in chunked(data, 100): # 一次插入 100 行. User.insert_many(batch).execute() insert_from 使用 SELECT 查询作为源 INSERT 数据 insert_from(query, fields) query：SELECT查询用作数据源 fields：要将数据插入的字段，此参数必须要的 ** 我们将 user表按原结构复制一个 user2表出来，以做演示 data = User.select(User.username, User.score, User.birthday) User2.insert_from(data, ['username', 'score', 'birthday']).execute() insert_from 是指从一个表查数据快速插入到另一个表 query = TweetArchive.insert_from( Tweet.select(Tweet.user, Tweet.message),fields=[Tweet.user, Tweet.message]).execute() API 应用于 INSERT INTO … SELECT FROM … 形式的查询 因为是 INSERT INTO … SELECT FROM … 形式的，所以数据源的列跟要插入的列必须保持一致 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-delete.html":{"url":"mysql/peewee-delete.html","title":"1.4.4 delete","keywords":"","body":"1.3.4 peewee之delete 删除调用delete()方法，使用execute()执行， 返回值为成功删除的数据条数 User.delete().where(User.id == 10).execute() User.delete().where(~fn.EXISTS(subq)) 要删除单个模型实例，可以使用 快捷方式。Model.delete_instance() delete_instance() user = User.get(User.id == 11) user.delete_instance() 返回删除条数 如果不存在则报UserDoesNotExist: instance matching query does not exist window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-update.html":{"url":"mysql/peewee-update.html","title":"1.4.5 update","keywords":"","body":"1.3.5 peewee之update save p = User(username='zhangsan', score=83, gender=1) p.save() p.username = 'abc' p.save() 在执行第一个 save() 方法的时候，主键没值，所以执行 INSERT，save() 方法执行之后，自增列的值就返回并赋给了模型实例，所以第二次调用 save() 执行的是 UPDATE。 模型中如没有指定主键，peewee 会自动增加一个名为 id 的自增列作为主键。 update 返回值影响行数 User.update({User.username: 'zhangsan', User.score: 78}).where(User.id == 12).execute() User.update({'username': 'zhangsan', 'score': 78}).where(User.id==12).execute() User.update(username='zhangsan', score=78).where(User.id == 12).execute() User.update(User.age=User.age+1).where(User.username == 12).execute() 原子更新 Atomic subquery = Tweet.select(fn.COUNT(Tweet.id)).where(Tweet.user == User.id) update = User.update(num_tweets=subquery) update.execute() upsert如指定键存在就更新，如不存在执行插入 无论以前是否存在过，存在更新，不存在则插入 replace与on_conflict_replace()是等效的 # last_login值将更新 user_id = User.replace(username='the-user', gmt_created=datetime.now()).execute() user_id = User.insert(username='the-user', gmt_created=datetime.now()).on_conflict_replace().execute() ON DUPLICATE KEY UPDATE class User(Model): username = TextField(unique=True) last_login = DateTimeField(null=True) login_count = IntegerField() #插入一个新用户 User.create(username='huey', login_count=0) # 模拟用户登录. 登录计数和时间戳，要么正确创建，要么更新。 now = datetime.now() userid = User.insert( username='maji', last_login=datetime.now(), login_count=1 ).on_conflict( conflict_target=[User.username], preserve=[User.last_login], update={User.login_count: User.login_count + 1} ).execute() class KV(Model): key = CharField(unique=True) value = IntegerField() KV.create(key='k1', value=1) # Demonstrate usage of EXCLUDED. # Here we will attempt to insert a new value for a given key. If that # key already exists, then we will update its value with the *sum* of its # original value and the value we attempted to insert -- provided that # the new value is larger than the original value. query = (KV.insert(key='k1', value=10) .on_conflict(conflict_target=[KV.key], update={KV.value: KV.value + EXCLUDED.value}, where=(EXCLUDED.value > KV.value))) # Executing the above query will result in the following data being # present in the \"kv\" table: # (key='k1', value=11) query.execute() # If we attempted to execute the query *again*, then nothing would be # updated, as the new value (10) is now less than the value in the # original row (11). window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-select.html":{"url":"mysql/peewee-select.html","title":"1.4.6 select","keywords":"","body":"1.3.6 peewee之select 一、get get 方法检索与给定查询匹配的单个实例 p1 = User.get(username='张三') p2 = User.get(username.Name == '李四') 当获取的结果不存在时，报 Model.DoesNotExist 异常。 如果有多条记录满足条件，则返回第一条 get_or_none 如果当获取的结果不存在时，不想报错，可以使用 Model.get_or_none() 方法，会返回 None，参数和 get 方法一致。 get_by_id 对于主键查找，还可以使用快捷方法Model.get_by_id()。 User.get_by_id(1) get_or_create 首先尝试检索匹配的行。如果失败，将创建一个新行。 p, created = User.get_or_create(username='赵六', defaults={'username': \"赵六\", 'score': 75, 'gender':1}) print(p, created) # 存在返回id false 存在添加后返回id true person, created = Person.get_or_create(first_name=first_name,last_name=last_name,defaults={'dob': dob, 'favorite_color': 'green'}) 二、select 获取总条数方法 User.select().count() 查询部分字段 user3= User.select(User.user_name) where 条件查询 user4 = User.select().where(User.id == 12) 随机查询(需要先引入fn) from peewee import fn user5 = User.select().order_by(fn.Random()).limit(2) 排序查询 正序 user6 = User.select().order_by(User.dept_id.asc()) 倒序加分页 user6 = User.select().order_by(User.age.desc()).paginate(3, 5) 参数1 从第几个数据开始 参数2 要取多少条数据 复合条件 逻辑符 含义 样例 & and Person.select().where((Person.Name == '张三') & (Person.Age == 30)) | or Person.select().where((Person.Name == '张三')|(Person.Age==30)) ~ not Person.select().where(~Person.Name == '张三') query1 = Person.select().where((Person.name == \"fff0\") | (Person.name == \"sss1\")) query2 = Person.select().where((Person.name == \"fff\") & (Person.is_relative == True)) 特别注意：有多个条件时，每个条件**必须*用 () 括起来。 当条件全为 \\and* 时，也可以用逗号分隔，*get* 和 *select* 中都可以： Person.get(Person.Name == '张三', Person.Age == 30) 比较运算符 运算符 含义 运算符 含义 == 等于 != 不等于 小于 小于等于 > 大于 >= 大于等于 x in y，其中 y 是列表或查询 >> x is y, 其中 y 可以是 None % x like y ** x like y st8 = User.select().where(User.score >= 80) st8 = StudentsInfo.select().where(StudentsInfo.english_sore>StudentsInfo.chinese_sore) st8 = User.select().where(User.username % '%子%') st8 = User.select().where(User.username % 'zhang*') 区分大小写 st8 = User.select().where(User.username ** 'zhang*') 不区分大小写 contains query = User.select().where(User.username.crontains('zhang')) in not_in query = User.select().where(User.id.in_([1, 5])) st9 = User.select(User.username).where(User.id > 880) sc = UserAuth.select().where(UserAuth.Auth.not_in(st9)) None / Null / Empty Message.select().where(Message.somecolumn.is_null(False)) 查询扩展字段 query = User.get_or_none(id = 1) query.penpal = 'langwang' query.girl_friend= 'xiaoma' res = model_to_dict(query , extra_attrs=[\"penpal\", \"girl_friend\"]) {'id': 13, 'gender': '0','score': 45, 'username': 'sunsan', 'girl_friend': 'xiaoma', 'penpal': 'langwang'} 字典展示(还可以tuples(),namedtuples(),objects()) user = User.select().dicts() user = User.select().tuples() user = User.select().namedtuples() Order by; Limit; Distinct; Group by; Having query = Person.select(Person.name).order_by(Person.name).limit(10).distinct() # 几乎和sql一模一样Person.select().order_by(Person.birthday.desc()) # 日期排序 query = Booking.select( Booking.facid, fn.SUM(Booking.slots) ).group_by( Booking.facid ).order_by( Booking.facid ) query = Booking.select( Booking.facility, fn.SUM(Booking.slots) ).group_by( Booking.facility ).having( fn.SUM(Booking.slots) > 1000 ).order_by( Booking.facility ) Tweet.select().order_by(-Tweet.created_date) # Similarly you can use \"+\" to indicate ascending order, though ascending 聚合函数 SELECT MAX(birthday) FROM person; query = Person.select(fn.MAX(Person.birthday)) SELECT name, is_relative FROM person WHERE birthday = (SELECT MAX(birthday) FROM person); MemberAlias = Member.alias() # 如果一个查询中用了两个表，需要这个Alias作为影子 subq =MemberAlias.select(fn.MAX(MemberAlias.joindate)) query = (Member.select(Person.is_relative, Person.name, ).where(Person.birthday == subq)) on_conflict class User(Model): username = TextField(unique=True) last_login = DateTimeField(null=True) login_count = IntegerField() # Insert a new user. User.create(username='huey', login_count=0) # Simulate the user logging in. The login count and timestamp will be # either created or updated correctly. now = datetime.now() rowid = (User .insert(username='huey', last_login=now, login_count=1) .on_conflict( preserve=[User.last_login], # Use the value we would have inserted. update={User.login_count: User.login_count + 1}) .execute()) 我们可以根据需要安全地调用upsert查询多次。 登录计数将自动增加，最后一个登录列将更新，并且不会创建重复的行。 join.left_outer SysDeptDb.select( BaseDatabase.id, BaseDatabase.db_name ).join( BaseDatabase, JOIN.LEFT_OUTER, on=(BaseDatabase.id == SysDeptDb.db_id) ).where( SysDeptDb.dept_id == dept, SysDeptDb.status == 1 ).dicts() fn.MAX from peewee import fn User.select(fn.MAX(User.score)).where(User.type == 1) 聚合行数 MemberAlias = Member.alias() # 如果一个查询中用了两个表，需要这个Alias作为影子 subq = MemberAlias.select(fn.MAX(MemberAlias.joindate)) query = (Member.select(Person.is_relative, Person.name, ).where(Person.birthday == subq)) EquClusterAlias = EquCluster.alias() equ_alias = EquClusterAlias.select( BaseDatabase.db_name ).join( BaseDatabase, on=((BaseDatabase.cluster_id == EquClusterAlias.id) |(BaseDatabase.cluster_name == EquClusterAlias.cluster_name)) ).where( EquClusterAlias.id == 1, EquClusterAlias.environment == 1 ).dicts() 三、事务 atomic和rollback with db.atomic() as transaction: # Opens new transaction. try: save_some_objects() except ErrorSavingData: # Because this block of code is wrapped with \"atomic\", a # new transaction will begin automatically after the call # to rollback(). transaction.rollback() error_saving = True atomic甚至可以多层嵌套 db = SqliteDatabase(':memory:') with db.atomic() as txn: # This is the outer-most level, so this block corresponds to # a transaction. User.create(username='charlie') with db.atomic() as nested_txn: # This block corresponds to a savepoint. User.create(username='huey') # This will roll back the above create() query. nested_txn.rollback() User.create(username='mickey') # When the block ends, the transaction is committed (assuming no error # occurs). At that point there will be two users, \"charlie\" and \"mickey\". 手动、半自动 # 纯手动用commit()提交，用rollback回滚 with db.transaction() as txn: User.create(username='mickey') txn.commit() # Changes are saved and a new transaction begins. User.create(username='huey') # Roll back. \"huey\" will not be saved, but since \"mickey\" was already # committed, that row will remain in the database. txn.rollback() # 半自动用savepoint上下文管理 with db.transaction() as txn: with db.savepoint() as sp: User.create(username='mickey') with db.savepoint() as sp2: User.create(username='zaizee') sp2.rollback() # \"zaizee\" will not be saved, but \"mickey\" will be. 四、其它 Person._meta.fields # 用访问_meta访问定义的meta Person._meta.primary_key Person._meta.database # 属性有：database， table_name， table_function， indexes， primary_key， constraints， schema， only_save_dirty， options， table_alias， depends_on， without_rowid .first() .exists() 五、简单示例 query = session.query(User) print list(query) #列出所有user print query.get(1) #根据主键显示 print query.filter_by(user_name='dongwm').first() #类似于SQL的where,打印其中的第一个 u = query.filter_by(user_name='dongwm').first() u.password = 'newpass' #修改其密码字段 session.commit() #提交事务 print query.get(1).password #打印会出现新密码 for instance insession.query(User).order_by(User.id): 根据id字段排序,打印其中的用户名和邮箱地址 printinstance.user_name, instance.email_address window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/peewee-web.html":{"url":"mysql/peewee-web.html","title":"1.4.7 框架整合","keywords":"","body":"1.3.7 peewee之框架整合 一、flask Flask和peewee是一个不错的组合，我适合任何规模的项目。Flask提供了两个钩子，我们将使用它们来打开和关闭数据库连接。收到请求后，我们将打开连接，然后在返回响应时将其关闭。 from flask import Flask from peewee import * database = SqliteDatabase('my_app.db') app = Flask(__name__) # This hook ensures that a connection is opened to handle any queries # generated by the request. @app.before_request def _db_connect(): database.connect() # This hook ensures that the connection is closed when we've finished # processing the request. @app.teardown_request def _db_close(exc): if not database.is_closed(): database.close() falsk_peewe 二、tornado 看起来像 tornado的RequestHandler类实现了两个钩子，可以在处理请求时用来打开和关闭连接。 from tornado.web import RequestHandler db = SqliteDatabase('my_db.db') class PeeweeRequestHandler(RequestHandler): def prepare(self): db.connect() return super(PeeweeRequestHandler, self).prepare() def on_finish(self): if not db.is_closed(): db.close() return super(PeeweeRequestHandler, self).on_finish() 在您的应用中，无需扩展默认值RequestHandler，现在您可以扩展PeeweeRequestHandler。 请注意，这并不解决如何与peewee异步使用 tornado或另一个事件循环。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-introduction.html":{"url":"mysql/sqlalchemy-introduction.html","title":"2.5 SQLAlchemy","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-model.html":{"url":"mysql/sqlalchemy-model.html","title":"1.5.1 model","keywords":"","body":"1.4.1 SQLAlchemy-model 一、字段类型 类型名 python中类型 说明 Integer int 普通整数，一般是32位 SmallInteger int 取值范围小的整数，一般是16位 BigInteger int或long 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 普通整数，一般是32位 String str 变长字符串 Text str 变长字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长或不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 时间 Time datetime.datetime 日期和时间 LargeBinary str 二进制文件 二、字段初始化参数(字段类型都接受的参数及其默认值) primary_key 如果为True，代表表的主键 unique 如果为True，代表这列不允许出现重复的值 index 如果为True，为这列创建索引，提高查询效率 nullable 如果为True，允许有空值，如果为False，不允许有空值 default 为这列定义默认值 三、关系选项 选项名 说明 backref 在关系的另一模型中添加反向引用 primary join 明确指定两个模型之间使用的联结条件 uselist 如果为False，不使用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondary join 在SQLAlchemy中无法自行决定时，指定多对多关系中的二级联结条件 四、根据模型生成数据 五、根据数据表生成模型 六、简单示例 from sqlalchemy import Column, Integer, String from Models import Base class User(Base): __tablename__ = 'User' id = Column('id', Integer, primary_key=True, autoincrement=True) name = Column('name', String(50)) age = Column('age', Integer) 模型支持的类型 Integer, String, Boolean, Date, DateTime, Float Column构造函数name名称、type列类型、autoincrement自增、default默认值、index索引、nullable可空、primary_key外键 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-connect.html":{"url":"mysql/sqlalchemy-connect.html","title":"1.5.2 connect","keywords":"","body":"1.4.2 sqlalchemy之connect 一、常规链接 # 导入相关数据包 from sqlalchemy.orm import sessionmaker from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import create_engine, Column, Integer, String, equence engine = create_engine(\"mysql+pymysql://root:1qaz2wsx@127.0.0.1:3306/testdb?charset=utf8\", echo=True) # 创建到数据库的连接,echo=True表示用logging输出调试结果 Base = declarative_base() class User(Base): __tablename__ = 'user' id = Column(Integer, Sequence('user_id_seq'), primary_key=True) name = Column(String(50)) fullname = Column(String(50)) password = Column(String(12)) def __repr__(self): return \"\" % (self.name, self.fullname, self.password) \"\"\"创建引擎中的所有表。这相当于“CREATE TABLE”原始的SQL语句。\"\"\" Base.metadata.create_all(engine) # 实例化一个对象，并赋值 ed_user = User(name='ed', fullname='Ed Jones', password='edspassword') # 创建会话链接，并关联引擎 Session = sessionmaker(bind=engine, expire_on_commit=False) # 创建一个session实例 session = Session() # 将数据添加到seesion中 echo 参数是用来设置SQLAlchemy日志的 create_engine() 的返回值是Engine的一个实例，通过方言来处理数据库和数据库的API 数据库事务的提交,sisson自动过期而不需要关闭 二、连接池 from sqlalchemy.orm import sessionmaker, relationship # 函数是最常使用的创建最顶层可用于整个应用Session 的方法,Session管理着所有与数据库之间的会话 from sqlalchemy.ext.declarative import declarative_base # 要继承这个类 from sqlalchemy import Column, ForeignKey # 写字段 条件 from sqlalchemy import Integer,String,Text,Date,DateTime, Column from sqlalchemy import create_engine, Table # 链接数据库 # 单独执行 model 文件 Base = declarative_base() class Users(Base): __tablename__ = 'users' # 要建的 表名 id = Column(Integer, primary_key=True) # username = Column(String(32), index=True, nullable=False) # index加 索引nullable 为空 depart_id = Column(Integer) # Integer int password = Column(String(64), nullable=False) email = Column(String(64), nullable=False, index=True) def create_all(): engine = create_engine( \"mysql+pymysql://root:1qaz2wsx@127.0.0.1:3306/testdb?charset=utf8\", max_overflow=0, # 超过连接池大小外最多创建的连接 pool_size=5, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错 pool_recycle=-1 # 多久之后对线程池中的线程进行一次连接的回收（重置） ) Base.metadata.create_all(engine) def drop_all(): '''删表:return:''' engine = create_engine( \"mysql+pymysql://root:123456@127.0.0.1:3306/db2?charset=utf8\", max_overflow=0, # 超过连接池大小外最多创建的连接 pool_size=5, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错 pool_recycle=-1 # 多久之后对线程池中的线程进行一次连接的回收（重置） ) Base.metadata.drop_all(engine) if __name__ == '__main__': drop_all() create_all() window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-insert.html":{"url":"mysql/sqlalchemy-insert.html","title":"1.5.3 insert","keywords":"","body":"1.4.3 sqlalchemy之insert peewee连接数据库根据场景目前总结常用的集中情况情况，可根据使用的场景自行选择连接方式。 一、insert 执行原生sql， 如果是增删改，需要commit session.execute('select * from User') add obj = Users(username='zhangsan', depart_id=10, email='123@qq.com') obj = Users(**{'username':'zhangsan', 'depart_id':10, 'password':'123', 'email':'123@qq.com'}) session.add(obj) session.commit() add_all session.add_all([ Users(username='zhangsan', depart_id=10, email='123@qq.com'), Users(username='lisi', depart_id=10, email='123@qq.com') ]) session.commit() 二、delete 方式一 user = User.query.order_by(User.id.desc()).first() user = session.query(Article).get(10) session.delete(user) session.commit() 方式二 User.query.filter(User.mobile='18512345678').delete() session.commit() 方法三 a = session.query(Article).get(10) session.delete(a) session.commit() 三、update 方式一 user = User.query.get(1) user.name = 'Python' db.session.add(user) db.session.commit() 使用merge方法，如果存在则修改，如果不存在则插入（只判断主键，不判断unique列）* user.name = 'admin' session.merge(user) 方式二 User.query.filter_by(id=1).update({'username':'python'}) session.commit() 方式三 session.query(Users).filter(Users.id ==4).update('name':Users.username+\"DSB\"},synchronize_session=False) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-select.html":{"url":"mysql/sqlalchemy-select.html","title":"1.5.4 select 其一","keywords":"","body":"1.2.4 sqlalchemy之select 《其一》 get 根据主键ID获取对象，若主键不存在返回None User.query.get(2) all 查询所有，返回列表 User.query.all() first() 查询第一个，返回对象 User.query.first() count() 计数 对每一项分别计数的时候，我们需要在func模块里通过func.count()来直接指定count()函数，下面我们可以单独计算一下每个名称的数量 from sqlalchemy import func session.query(func.count(User.name), User.name).group_by(User.name).all() SELECT count(*) FROM table session.query(func.count('*')).select_from(User).scalar() 根据User的主键来计算，那么select_from()可以去掉 session.query(func.count(User.id)).scalar() 起别名与查询部分字段 字段起别名 lable() query(Users.id, Users.name.label('cname')).all() 数据表起别名 from sqlalchemy.orm import aliased user_alias = aliased(User, name='user_alias') for row in session.query(user_alias, user_alias.name).all(): print(row.user_alias) filter_by 进行过虑 User.query.filter_by(username='python').first() User.query.filter_by(username='python, sex=1).first() # and关系 filter 进行过虑 User.query.filter(User.username=='python').first() 或 or_、与and_、非not_ from sqlalchemy import or_、or、not_ User.query.filter(or_(User.sex==1, User.username.endswith('jie'))).all() User.query.filter(and_(User.username != 'python',User.email.startswith('131'))).all() session.query(Users).filter(Users.id > 1, Users.username == 'python').all() User.query.filter(not_(User.sex == 1).all() offset 偏移，起始位置 User.query.offset(2).all() limit 获取限制数据 User.query.limit(3).all() order_by 排序 User.query.order_by(User.id).all() # 正序 User.query.order_by(User.id.desc()).all() # 倒序 distinct 去除查询 from sqlalchemy import distinct users = session.query(distinct(User.name).label('name')).all() between 之间查询 session.query(Users).filter(Users.id.between(1, 3), Users.username == 'python').all() in 与 not in session.query(Users).filter(Users.id.in_([1,3,4])).all() session.query(Users).filter(~Users.id.in_([1,3,4])).all() session.query(Users).filter(User.name.in_(['ed', 'wendy', 'jack'])) # works with query objects too: session.query(Users).filter(User.name.in_( session.query(User.name).filter(User.name.like('%ed%')) )) is null 和 is not null session.query(Users).filter(User.name == None) # alternatively, if pep8/linters are a concern session.query(Users).filter(User.name.is_(None)) session.query(Users).filter(User.name != None) # alternatively, if pep8/linters are a concern session.query(Users).filter(User.name.isnot(None)) and 和 or from sqlalchemy import and_, or_ session.query(User).filter(and_(User.name == 'ed', User.fullname == 'Ed Jones')).all() session.query(User).filter(User.name == 'ed', User.fullname == 'Ed Jones') session.query(User).filter(User.name == 'ed').filter(User.fullname == 'Ed Jones') session.query(Users).filter(or_(Users.id 3),Users.extra != \"\") ).all() first() 对查询结果进行了一个限制-返回列表的第一个值 all()all() 返回一个列表 one 创建Query查询，匹配不到，返回一个错误，或者匹配到多个值也会返回错误 user = session.query(User).filter(User.id=='5').one() one_or_none() 查询不到直接返回None，匹配到多个值也会返回错误 user = session.query(User).filter(User.id=='5').one_or_none() exists查询(不存在则为~exists()) from sqlalchemy.sql import exists session.query(User.name).filter(~exists().where(User.role_id == Role.id)) any 除了exists，any也可以表示EXIST session.query(Role).filter(Role.users.any()) random from sqlalchemy.sql.functions import random user = session.query(User).order_by(random()).first() 通配符 ret = session.query(Users).filter(Users.name.like('e%')).all() ret = session.query(Users).filter(~Users.name.like('e%')).all() # ~ 是 not ret = session.query(User).filter(User.name.like('%ed%')) match session.query(User).filter(User.name.match('wendy')) match() 和数据库底层有关 使用MATCH 或者 CONTAINS 来实现 切片 result = session.query(Users)[1:2] group by 分组 from sqlalchemy.sql import func users = session.query(func.count(User.name), User.age).group_by(User.age) ret = session.query( Users.depart_id, func.count(Users.id), ).group_by( Users.depart_id ).having( func.count(Users.id) >= 2 ).all() union 和 union all \"\"\" 组合: select id,name from users UNION #去重组合 不去重union all select id,name from users; \"\"\" # q1 = session.query(Users.name).filter(Users.id > 2) # q2 = session.query(Favor.caption).filter(Favor.nid 2) # q2 = session.query(Favor.caption).filter(Favor.nid 其它 scalar()援引自one()函数，查询成功之后会返回这一行的第一列参数 query = session.query(User.id).filter(User.name == 'ed').order_by(User.id) query.scalar() window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-fix-select.html":{"url":"mysql/sqlalchemy-fix-select.html","title":"1.5.5 select 其二","keywords":"","body":"1.2.5 sqlalchemy之select 一、高级查询 复合查询 User.query.filter(User.name.startswith('13')).order_by(User.id.desc()).offset(2).limit(5).all() query = User.query.filter(User.name.startswith('13')) query = query.order_by(User.id.desc()) query = query.offset(2).limit(5) ret = query.all() 优化查询 user = User.query.filter_by(id=1).first() # 查询所有字段 select user_id, mobile...... select * from # 程序不要使用 select user_id, mobile,.... # 查询指定字段 from sqlalchemy.orm import load_only User.query.options(load_only(User.name, User.mobile)).filter_by(id=1).first() # 查询特定字段 聚合查询 from sqlalchemy import func db.session.query(Relation.user_id, func.count(Relation.target_user_id)).filter(Relation.relation == Relation.RELATION.FOLLOW).group_by(Relation.user_id).all() 二、多表关系 User模型 from sqlalchemy import Column, Integer, String from sqlalchemy import ForeignKey from sqlalchemy.orm import relationship from Models import Base class User(Base): __tablename__ = 'users' id = Column('id', Integer, primary_key=True, autoincrement=True) name = Column('name', String(50)) age = Column('age', Integer) # 添加角色id外键(关联到Role表的id属性) role_id = Column('role_id', Integer, ForeignKey('roles.id')) # 添加同表外键 second_role_id = Column('second_role_id', Integer, ForeignKey('roles.id')) # 添加关系属性，关联到role_id外键上 role = relationship('Role', foreign_keys='User.role_id', backref='User_role_id') # 添加关系属性，关联到second_role_id外键上 second_role = relationship('Role', foreign_keys='User.second_role_id', backref='User_second_role_id') Role模型 from sqlalchemy import Column, Integer, String from sqlalchemy.orm import relationship from Models import Base class Role(Base): __tablename__ = 'roles' id = Column('id', Integer, primary_key=True, autoincrement=True) name = Column('name', String(50)) # 添加关系属性，关联到User.role_id属性上 users = relationship(\"User\", foreign_keys='User.role_id', backref=\"Role_users\") # 添加关系属性，关联到User.second_role_id属性上 second_users = relationship(\"User\", foreign_keys='User.second_role_id', backref=\"Role_second_users\") 设置外键的时候ForeignKey('roles.id')这里面使用的是表名和表列 在设置关联属性的时候relationship('Role', foreign_keys='User.role_id', backref='User_role_id')，这里的foreign_keys使用的时候类名和属性名 u = User(name='tobi', age=200) r1 = Role(name='admin') r2 = Role(name='user') u.role = r1 u.second_role = r2 session.add(u) session.commit() # 查询（对于外键关联的关系属性可以直接访问，在需要用到的时候session会到数据库查询） roles = session.query(Role).all() for role in roles: print 'role:{0} users' for user in role.users: print '{0}'.format(user.name) print 'role:{0} second_users' for user in role.second_users: print '{0}'.format(user.name) 上面表示的是一对多（多对一）的关系，还有一对一，多对多，如果要表示一对一的关系，在定义relationship的时候设置uselist为False（默认为True），如在Role中 class Role(Base): ... user = relationship(\"User\", uselist=False, foreign_keys='User.role_id', backref=\"Role_user\") 三、关联查询 使用ForeignKey class User(db.Model): ... profile = db.relationship('UserProfile', uselist=False) followings = db.relationship('Relation') class UserProfile(db.Model): id = db.Column('user_id', db.Integer, db.ForeignKey('user_basic.user_id'), primary_key=True, doc='用户ID') ... class Relation(db.Model): user_id = db.Column(db.Integer, db.ForeignKey('user_basic.user_id'), doc='用户ID') ... # 测试 user = User.query.get(1) user.profile.gender user.followings 使用primaryjoin class User(db.Model): ... profile = db.relationship('UserProfile', primaryjoin='User.id==foreign(UserProfile.id)', uselist=False) followings = db.relationship('Relation', primaryjoin='User.id==foreign(Relation.user_id)') # 测试 user = User.query.get(1) user.profile.gender user.followings 指定字段关联查询 class Relation(db.Model): ... target_user = db.relationship('User', primaryjoin='Relation.target_user_id==foreign(User.id)', uselist=False) from sqlalchemy.orm import load_only, contains_eager Relation.query.join(Relation.target_user).options(load_only(Relation.target_user_id), contains_eager(Relation.target_user).load_only(User.name)).all() 关联查询a表字段，b表字段；用先join 然后再contains_eager选择相应字段 四、多表查询 由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。 例如，如果一个User拥有多个Book，就可以定义一对多关系如下： class User(Base): __tablename__ = 'user' id = Column(String(20), primary_key=True) name = Column(String(20)) # 一对多: books = relationship('Book') class Book(Base): __tablename__ = 'book' id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey('user.id')) 当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。 多表查询通常使用join内连接进行表连接，第一个参数为表名，第二个参数为条件，例如 users = db.session.query(User).join(Role, Role.id == User.role_id) for u in users: print u.name 还可以直接查询多个表，如下 result = db.session.query(User, Role).filter(User.role_id = Role.id) # 这里选择的是两个表，使用元组获取数据 for u, r in result: print u.name 五、事务 environ = {'wsgi.version':(1,0), 'wsgi.input': '', 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/', 'SERVER_NAME': 'itcast server', 'wsgi.url_scheme': 'http', 'SERVER_PORT': '80'} with app.request_context(environ): try: user = User(mobile='18911111111', name='itheima') db.session.add(user) db.session.flush() # 将db.session记录的sql传到数据库中执行 profile = UserProfile(id=user.id) db.session.add(profile) db.session.commit() except: db.session.rollback() 六、其他 backref 在关系的另一模型中添加反向引用 primary join 明确指定两个模型之间使用的联结条件 uselist 如果为False，不使用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondary join 在SQLAlchemy中无法自行决定时，指定多对多关系中的二级联结条件 # 一对多关系, 同步到数据库外键的关系 user_id = db.Column(db.Integer, db.ForeignKey('user.id')) # 外检不允许为空 user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False) # 外检不允许为空 # 增加一个字段，代码层面的关系 articles = db.relationship('Article', backref='user', lazy='dynamic') comments = db.relationship('Comment', backref='user') comments = db.relationship('Comment', backref='news') window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mysql/sqlalchemy-flask.html":{"url":"mysql/sqlalchemy-flask.html","title":"1.5.6 flask-sqlalchemy","keywords":"","body":"1.4.6 sqlalchemy之insert 一、 安装Flask-SQLAlchemy pip install flask-sqlalchemy 二、数据库连接设置 config.py from flask import Flask app = Flask(__name__) class Config(object): SQLALCHEMY_DATABASE_URI = 'mysql://root:mysql@127.0.0.1:3306/leqiaosu' SQLALCHEMY_TRACK_MODIFICATIONS = False # 在Flask中是否追踪数据修改 SQLALCHEMY_ECHO = True # 显示生成的SQL语句，可用于调试 app.config.from_object(Config) 其他配置 名字 备注 SQLALCHEMY_DATABASE_URI 用于连接的数据库 URI 。例如:sqlite:////tmp/test.dbmysql://username:password@server/db SQLALCHEMY_BINDS 一个映射 binds 到连接 URI 的字典。更多 binds 的信息见用 Binds 操作多个数据库。 SQLALCHEMY_ECHO 如果设置为Ture， SQLAlchemy 会记录所有 发给 stderr 的语句，这对调试有用。(打印sql语句) SQLALCHEMY_RECORD_QUERIES 可以用于显式地禁用或启用查询记录。查询记录 在调试或测试模式自动启用。更多信息见get_debug_queries()。 SQLALCHEMY_NATIVE_UNICODE 可以用于显式禁用原生 unicode 支持。当使用 不合适的指定无编码的数据库默认值时，这对于 一些数据库适配器是必须的（比如 Ubuntu 上 某些版本的 PostgreSQL ）。 SQLALCHEMY_POOL_SIZE 数据库连接池的大小。默认是引擎默认值（通常 是 5 ） SQLALCHEMY_POOL_TIMEOUT 设定连接池的连接超时时间。默认是 10 。 SQLALCHEMY_POOL_RECYCLE 多少秒后自动回收连接。这对 MySQL 是必要的， 它默认移除闲置多于 8 小时的连接。注意如果 使用了 MySQL ， Flask-SQLALchemy 自动设定 这个值为 2 小时。 三、链接数据库 方式一： db = SQLAlchemy(app) 方式二： db = SQLAlchemy() db.init_app(app) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-introduction.html":{"url":"redis/redis-introduction.html","title":"2.redis","keywords":"","body":"Introduction All for the purpose not to marry out of love is where bullying 化用这句话： 所有不知应用场景的学习，都是瞎学。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-install.html":{"url":"redis/redis-install.html","title":"2.1 安装配置","keywords":"","body":"背景 redis和mysql要根据具体业务场景去选型 mysql：数据放在磁盘 redis：数据放在内存 redis适合放一些频繁使用，比较热的数据，因为是放在内存中，读写速度都非常快 首先要知道mysql存储在磁盘里，redis存储在内存里，redis既可以用来做持久存储，也可以做缓存，而目前大多数公司的存储都是mysql + redis, 其中：mysql作为主存储，redis作为辅助存储被用作缓存，加快访问读取的速度，提高性能。 那么为什么不直接全部用redis存储呢？ 因为redis存储在内存中，如果存储在内存中，存储容量肯定要比磁盘少很多，那么要存储大量数据，只能花更多的钱去购买内存，造成在一些不需要高性能的地方是相对比较浪费的，所以目前基本都是mysql(主) + redis(辅)，在需要性能的地方使用redis，在不需要高性能的地方使用mysql，好钢用在刀刃上 mysql支持sql查询，可以实现一些关联的查询以及统计； redis对内存要求比较高，在有限的条件下不能把所有数据都放在redis mysql偏向于存数据，redis偏向于快速取数据，但redis查询复杂的表关系时不如mysql，所以可以把热门的数据放redis，mysql存基本数据 冷热数据 高速的缓存服务(用户经常访问的数据从数据库搬到内存) 实时热点排行 投票点赞 消息队列 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-windos-install.html":{"url":"redis/redis-windos-install.html","title":"2.1.1 windos 安装","keywords":"","body":"2.1.1 redis之windows版本安装 1. 下载 github redis-download 2. 解压到安装目录 3.启动服务端 redis-server.exe redis.windows.conf 4. 启动客户端 Redis-cli.exe redis-cli.exe -h 127.0.0.1 -p 6379 5. 绑定ip设置密码 进入安装目录修改redis.windows-conf文件 requirepass 1qaz2wsx bind 0.0.0.0 redis-cli.exe -p 6379 -a 1qaz2wsx window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-ubuntu-install.html":{"url":"redis/redis-ubuntu-install.html","title":"2.1.2 ubuntu 安装","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-centos-install.html":{"url":"redis/redis-centos-install.html","title":"2.1.3 centos 安装","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-config.html":{"url":"redis/redis-config.html","title":"2.1.4 配置参数","keywords":"","body":"2.1.4 redis之配置参数 # 默认情况下，redis不是在后台模式运行的，如果需要在后台进程运行，把该项的值更改为yes，默认为no daemonize：是否以后台daemon方式运行 # 如redis服务以后台进程运行的时候，Redis默认会把pid写入/run/redis.pid文件组，你可以配置到其他文件路径。 # 当运行多个redis服务时，需要指定不同的pid文件和端口 pidfile：pid文件位置 # 指定redis监听端口，默认为6379 # 如果端口设置为0，Redis就不会监听TCP套接字。 port：监听的端口号 # 指定redis只接收来自于该IP地址的请求，如果不进行设置，默认将处理所有请求， # 在生产环境中最好设置该项 bind 127.0.0.1 # 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接 # 默认值：0代表禁用，永不关闭 timeout：请求超时时间 # 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果不指定的话，Redis就不会通过unix套接字来监听。 # unixsocket /tmp/redis.sock # unixsocketperm 755 # 指定日志记录级别 # Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose # debug 记录很多信息，用于开发和测试 # varbose 很多精简的有用信息，不像debug会记录那么多 # notice 普通的verbose，常用于生产环境 # warning 只有非常重要或者严重的信息会记录到日志 loglevel：log信息级别 # 配置log文件名称和全路径地址 # 默认值为stdout，使用“标准输出”，默认后台模式会输出到/dev/null logfile：log文件位置 # 可用数据库数，默认值为16，默认数据库存储在DB 0号ID库中，无特殊需求，建议仅设置一个数据库 databases 1 # 查询数据库使用 SELECT # dbid介于 0 到 'databases'-1 之间 databases：开启数据库的数量 save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。 rdbcompression：是否使用压缩 dbfilename：数据快照文件名（只是文件名，不包括目录） dir：数据快照的保存目录（这个是目录） appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。 appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步） ########## REPLICATION 同步 ########## # 主从同步。通过 slaveof 配置来实现Redis实例的备份。 # 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。 # 当本机为从服务时，设置主服务的IP及端口，在Redis启动时，它会自动从主服务进行数据同步 # slaveof # 如果主服务master设置了密码(通过下面的 \"requirepass\" 选项来配置)，slave服务连接master的密码，那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。 #当本机为从服务时，设置主服务的连接密码 # masterauth # 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能： # 1) 如果 slave-serve-stale-data 设置为 \"yes\" (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。 # 2) 如果 slave-serve-stale-data 设置为 \"no\"，slave会回复\"正在从master同步(SYNC with master in progress)\"来处理各种请求，除了 INFO 和 SLAVEOF 命令。 slave-serve-stale-data yes # slave根据指定的时间间隔向服务器发送ping请求。 # 时间间隔可以通过 repl_ping_slave_period 来设置。 # 默认10秒 # repl-ping-slave-period 10 # 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。 # 默认值60秒。 # 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。 # repl-timeout 60 ########## SECURITY 安全 ########## # 要求客户端在处理任何命令时都要验证身份和设置密码。 # 如果你不相信请求者，这个功能很有用。 # 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证(例如：它们运行在自己的服务器上。) # 警告：外部使用者可以每秒尝试150k的密码来试图破解密码，这意味着你需要一个高强度的密码，否则破解太容易了。 # 设置连接密码 # requirepass foobared # 命令重命名，可设置多个 # 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法知道它。 # 例如: # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 # rename-command info info_biran # rename-command set set_biran # 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令： # rename-command CONFIG \"\" ########## LIMITS 限制 ########## # 设置最大同时连接客户端数量。 # 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。 # 特殊值\"0\"表示没有限制。 # 一旦达到这个限制，Redis会关闭所有新连接并发送错误\"达到最大用户数上限(max number of clients reached)\" # maxclients 128 # 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略(参见：maxmemmory-policy：内存策略设置)删除key。 # 如果因为删除策略问题Redis无法删除key，或者策略设置为 \"noeviction\"，Redis会回复需要更多内存的错误信息给命令。 # 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。 # 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候(使用 \"noeviction\" 策略)的时候，这个选项还是满有用的。 # 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。 # 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。 # 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。 # (如果策略设置为\"noeviction\"的话就不无所谓了) # 设置最大内存，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。 # maxmemory 256000000分配256M内存 # maxmemory # 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选： # volatile-lru -> 根据LRU算法生成的过期时间来删除。 # allkeys-lru -> 根据LRU算法删除任何key。 # volatile-random -> 根据过期设置来随机删除key。 # allkeys->random -> 无差别随机删。 # volatile-ttl -> 根据最近过期时间来删除(辅以TTL) # noeviction -> 谁也不删，直接在写操作时返回错误。 # 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。 # 这里涉及的命令：set setnx setex append # incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd # sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby # zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby # getset mset msetnx exec sort # 默认值如下： # maxmemory-policy volatile-lru # LRU和最小TTL算法的实现都不是很精确，但是很接近(为了省内存)，所以你可以用样例做测试。 # 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。 # maxmemory-samples 3 ########## APPEND ONLY MODE 纯累加模式 ########## # 默认情况下，Redis是异步的把数据导出到磁盘上。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中，这种情况下，当Redis宕机的时候，最新的数据就丢了。 # 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。 # 每次启动时Redis都会把这个文件的数据读入内存里。 # 注意，异步导出的数据库文件和纯累加文件可以并存(此时需要把上面所有\"save\"设置都注释掉，关掉导出机制)。 # 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。 # 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。 # 设置：yes为纯累加模式 appendonly no # 设置纯累加文件名字及保存路径，默认：\"appendonly.aof\" # appendfilename appendonly.aof # fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。 # 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。 # Redis支持三种不同的模式： # no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。 # always：每次写操作都立刻写入到aof文件。慢，但是最安全。 # everysec：每秒写一次。折衷方案。 # 默认的 \"everysec\" 通常来说能在速度和数据安全性之间取得比较好的平衡。 # 如果你真的理解了这个意味着什么，那么设置\"no\"可以获得更好的性能表现(如果丢数据的话，则只能拿到一个不是很新的快照)； # 或者相反的，你选择 \"always\" 来牺牲速度确保数据安全、完整。 # 如果不确定这些模式的使用，建议使用 \"everysec\" # appendfsync always appendfsync everysec # appendfsync no # 如果AOF的同步策略设置成 \"always\" 或者 \"everysec\"，那么后台的存储进程(后台存储或写入AOF日志)会产生很多磁盘I/O开销。 # 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。 # 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。 # 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。 # 这就意味着如果有子进程在进行保存操作，那么Redis就处于\"不可同步\"的状态。 # 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。(默认Linux设定) # 如果你有延迟的问题那就把这个设为 \"yes\"，否则就保持 \"no\"，这是保存持久数据的最安全的方式。 no-appendfsync-on-rewrite no # 自动重写AOF文件 # 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。 # 工作原理：Redis记住上次重写时AOF日志的大小(或者重启后没有写操作的话，那就直接用此时的AOF文件)， # 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。 # 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。 # 指定百分比为0会禁用AOF自动重写特性。 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb ########## SLOW LOG 慢查询日志 ########## # Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。 # 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间(这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景) # 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。 # 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。 # 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。 slowlog-log-slower-than 10000 # 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。 slowlog-max-len 128 ########## VIRTUAL MEMORY 虚拟内存 ########## ### 警告！虚拟内存在Redis 2.4是反对的，因性能问题，2.4版本 VM机制彻底废弃，不建议使用此配置！！！！！！！！！！！ # 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。 # 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。 # 要使用虚拟内存，只要把 \"vm-enabled\" 设置为 \"yes\"，并根据需要设置下面三个虚拟内存参数就可以了。 vm-enabled no # 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。 # 最好的保存交换文件(被随机访问)的介质是固态硬盘(SSD)。 # *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。 # 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。 vm-swap-file /tmp/redis.swap # \"vm-max-memory\" 配置虚拟内存可用的最大内存容量。 # 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。 # \"vm-max-memory\" 设置为0表示系统会用掉所有可用内存，建议设置为剩余内存的60%-80%。 # 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。 vm-max-memory 0 # Redis交换文件是分成多个数据页的。 # 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。 # 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。 # 如果数据页太小，那用于存储的交换空间就会更少(假定你设置相同的数据页数量) # 如果你使用很多小对象，建议分页尺寸为64或32个字节。 # 如果你使用很多大对象，那就用大一些的尺寸。 # 如果不确定，那就用默认值 :) vm-page-size 32 # 交换文件里数据页总数。 # 根据内存中分页表(已用/未用的数据页分布情况)，磁盘上每8个数据页会消耗内存里1个字节。 # 交换区容量 = vm-page-size * vm-pages # 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。 # 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。 vm-pages 134217728 # 同时可运行的虚拟内存I/O线程数，即访问swap文件的线程数。 # 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。 # 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。 # 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。 # 设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证. vm-max-threads 4 ########## ADVANCED CONFIG 高级配置 ########## # 当有大量数据时，适合用哈希编码(这会需要更多的内存)，元素数量上限不能超过给定限制。 # Redis Hash是value内部为一个HashMap，如果该Map的成员数比较少，则会采用类似一维线性的紧凑格式来存储该Map, 即省去了大量指针的内存开销，如下2个条件任意一个条件超过设置值都会转换成真正的HashMap， # 当value这个Map内部不超过多少个成员时会采用线性紧凑格式存储，默认是64,即value内部有64个以下的成员就是使用线性紧凑存储，超过该值自动转成真正的HashMap。 hash-max-zipmap-entries 512 # 当 value这个Map内部的每个成员值长度不超过多少字节就会采用线性紧凑存储来节省空间。 hash-max-zipmap-value 64 # 与hash-max-zipmap-entries哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。 # list数据类型多少节点以下会采用去指针的紧凑存储格式 list-max-ziplist-entries 512 # list数据类型节点值大小小于多少字节会采用紧凑存储格式 list-max-ziplist-value 64 # 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。 # 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。 set-max-intset-entries 512 # 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。 # 这种编码只适合长度和元素都符合下面限制的有序序列： zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表(顶级键值映射表)。 # redis所用的哈希表实现(见dict.c)采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁； # 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。 # 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。 # 建议： # 如果你对延迟比较在意的话就用 \"activerehashing no\"，每个请求延迟2毫秒不太好嘛。 # 如果你不太在意延迟而希望尽快释放内存的话就设置 \"activerehashing yes\"。 activerehashing yes ########## INCLUDES 包含 ########## # 包含一个或多个其他配置文件。 # 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。 # 包含文件特性允许你引人其他配置文件，所以好好利用吧。 # include /path/to/local.conf # include /path/to/other.conf 修改配置后，如果配置文件涉及到中文内容记得将文件存为UTF-8编码。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-usage.html":{"url":"redis/redis-usage.html","title":"2.2 数据操作","keywords":"","body":"2.2 redis操作类型 Redis是一个开源的Key-Value存储redis层面，永远只有一个键（字符串对象，值的种类有字符串对象，队列对象，集合对象，hash对象） string类型 增删改查：set get del decrby（减少指定整数） incrby（增加指定整数） incrbyfloat（增加指定的单精度） 批量：mset mget 自增, 自减：incr decr 追加：append（返回长度） 删除所有的key flushall 获取getrange hash类型 增删改查：hset hget hgetall keys hkeys keys hvals keys hdel keys field list类型 lisy是基于双向链表实现的，用于评论系统，新闻分页列表，消息队列等 lpush 左边插入 返回个数 rpush 右边插入 返回个数 lpop 移除左边 返回移除的值 rpop 移除右边 llen 列表个数 lrange key start stop 下标 （0 -1全部，0 1 前两个，-2 -1 倒数最后两个） set集合 增删改查： sadd srem/spop(随机弹出元素) smembers 个数 scard zset有序集合 增删改查： zadd 经典文档 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-string.html":{"url":"redis/redis-string.html","title":"2.2.1 string","keywords":"","body":"2.2.1 String字符串基本操作 字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的， 我们常使用的 set key value 命令就是字符串。 常用在缓存、计数、共享Session、限速等。 常用操作命令如下 序号 命令 描述 1 set key value 设置指定 key 的值 2 get key 获取指定 key 的值 3 mset key value key2 value2 同时设置一个或多个 key-value 对。 4 mget key1 key2 获取所有(一个或多个)给定 key 的值 5 setnx key value 只有在 key 不存在时设置 key 的值 6 setex key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) 7 strlen key 返回 key 所储存的字符串值的长度 8 incr key 将 key 中储存的数字值增一 9 decr key 将 key 中储存的数字值减一 10 getrange key start end 返回 key 中字符串值的子字符 11 getset key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value) 1.1 常用操作命令 SET 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。 设置键值 set key value set username zhangsan GET 根据键获取值，如果不存在此键则返回nil get key get username MSET 设置多个键值 mset key1 value1 key2 value2 ... mset zhangsan 18 lisi 19 wangwu 20 追加 append key value append maliu 21 和set 本质无区别，由单个设为多个而已 MGET 根据多个键获取多个值 mget key1 key2 ... mget zhangsan lisi wangwu SETEX 设置键值及过期时间，以秒为单位 setex key seconds value setex token 3 JZJOViZOdHcczGDEXMeu8lZe 注 setex zhangsan 18 18 lisi 19 19 wangwu 20 20 没有此用法 INCR 将key中储存的数字增加一 incr key set read 2000 incr read # 此时输出2001 注: 阅读量点赞量评论量 DECR 将key中储存的数字减一 decr key set read 2000 decr read # 此时输出1999 注: 一些资源的消耗 SETNX 只有在 key 不存在时设置 key 的值 setnx key value setnx name zhangsan 注: 已有key值情况下，不会覆盖更新，也不会创建新的 STRLEN 返回 key 所储存的字符串值的长度 strlen key strlen name # 输出为8 zhangsan 基本的命令：get、set 语法：get key，set key value value如果有空格需要双引号以示区分 整数递增：incr 语法：incr key 默认值为0，所以首先执行命令得到 1 ，不是整型提示错误 增加指定的整数：incrby 语法：incrby key increment 整数递减：decr 语法：decr key 默认值为0，所以首先执行命令得到 -1，不是整型提示错误 减少指定的整数：decrby 语法：decrby key increment 增加指定浮点数：incrbyfloat 语法：incrbyfloat key increment 向尾部追加值：append 语法：append key value redis客户端并不是输出追加后的字符串，而是输出字符串总长度 获取字符串长度：strlen语法：strlen key 如果键不存在返回0，注意如果有中文时，redis是使用utf-8编码中文 获取多个键值：mget 语法：mget key key2 例如：mget key1 key2 设置多个键值：mset 语法：mset key value key2 value2 例如：mset key1 1 key2 \"hello redis\" 二进制指定位置值：getbit 语法：getbit key offset 例如：getbit key1 2 ，key1为hello 返回 1，返回的值只有0或1，当key不存在或超出实际长度时为0 设置二进制位置值：setbit 语法：setbit key offset value ，返回该位置的旧值 二进制是1的个数：bitcount 语法：bitcount key [start end] ，start 、end为开始和结束字节 位运算：bitop 语法：bitop operation destkey key key2，operation支持and、or、xor、not 偏移：bitpos 语法：bitpos key bit [start] [end] window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-key.html":{"url":"redis/redis-key.html","title":"2.2.2 key","keywords":"","body":"2.2.2 key命令基本操作 常用操作命令如下 序号 命令 描述 1 keys pattern 查找键，参数⽀持正则表达式 2 exists key 判断键是否存在，如果存在返回1，不存在返回0 3 type key 查看键对应的value的类型 4 del key1 key2 ... 删除键及对应的值 5 expire key seconds 设置过期时间，以秒为单位， 有指定过期时间则⼀直存在，直到使⽤DEL移除 查看所有键 keys * 查看以a开头的键 keys zhang* 查看key为张三键是否存在 exists zhangsan 查看key为redis类型 type key 删除某键 del key1 key2 设立过期时间 expire zhangsan 20 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-hash.html":{"url":"redis/redis-hash.html","title":"2.2.3 hash","keywords":"","body":"2.2.3 Hash哈希基本操作 在Redis中，哈希类型是指键值本身又是一个键值对 结构， 形如value={{field1，value1}，…{fieldN，valueN}}， 添加命令：hset key field value。 哈希可以用来存放用户信息，比如实现购物车 常用操作命令如下 1 hset key field value 设置单个属性将哈希表 key 中的字段 field 的值设为 value 2 hkeys key 获取⼀个属性的值获取存储在哈希表中指定字段的值 3 hmset key field1 value1 field2 value2 设置多个属性同时将多个 field-value (域-值)对设置到哈希表 key 中 4 hmget key field1 field2 ... 获取多个属性的值获取所有给定字段的值 4 hmgetall key 获取在哈希表中指定 key 的所有字段和值 4 hexists key field 查看哈希表key中，指定的字段是否存在 4 hsetnx key field value 只有在字段 field 不存在时，设置哈希表字段的值 5 hkeys key 获取指定键所有的属性 6 hvals key 获取所有属性的值 7 del key 删除整个hash键及值 8 hdel key field1 field2 ... 删除属性，属性对应的值会被⼀起删除删除一个或多个哈希表字段 散列类型hash 设置单个：HSET 语法：HSET key field value，不存在时返回1，存在时返回0，没有更新和插入之分 设置多个：HMSET 语法：HMSET key field value [field value ...] 读取单个：HGET 语法：HGET key field，不存在是返回nil 读取多个：HMGET 语法：HMGET key field [field ...] 读取全部：HGETALL 语法：HGETALL key，返回时字段和字段值的列表 判断字段是否存在：HEXISTS 语法：HEXISTS key field，存在返回1 ，不存在返回0 字段不存在时赋值：HSETNX 语法：HSETNX key field value，与hset命令不同，hsetnx是键不存在时设置值 增加数字：HINCRBY 语法：HINCRBY key field increment ，返回增加后的数，不是整数时会提示错误 删除字段：HDEL 语法：HDEL key field [field ...] ，返回被删除字段的个数 只获取字段名：HKEYS 语法：HKEYS key ，返回键的所有字段名 只获取字段值：HVALS 语法：HVALS key ，返回键的所有字段值 字段数量：HLEN 语法：HLEN key ，返回字段总数 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-list.html":{"url":"redis/redis-list.html","title":"2.2.4 list","keywords":"","body":"2.2.4 list列表基本操作 常见的存储结构,它是一个双向链表,即可以作为栈结构也可以作为队列结构. 列表的元素类型为string, 按照插⼊顺序排序，可以在列表头部尾部添加元素 常用操作命令如下 1 llen key 获取列表长度 2 lpush key value1 value2 将一个或多个值插入到列表头部 3 lpop key 移出并获取列表的第一个元素 4 rpush key value1 value2 据将一个或多个值插入到列表尾部 5 rpop key 移除并获取列表最后一个元素 6 linsert key before 现有元素 新元素 在指定元素的前插⼊新元素 7 linsert key after 现有元素 新元素 在指定元素后插⼊新元素 8 lrange key start stop 获取列表指定范围内的元素 tart、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0索引可以是负数 表示从尾部开始计数，如-1表示最后⼀个元素 列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 9 lset key index value 设置指定索引位置的元素值 10 lrem key count value 将列表中前count次出现的值为value的元素移除 count>0:从头往尾移除 count count = 0: 移除所有 11 rpushx key value 为已存在的列表添加值 使用场景 1. 取出最新n个消息(不涉及复杂排序) 比如最新1000个访客,就可以使用list,同时使用LTRIM key 0 1000,只保存最新的1000个 2. 作为队列 将Redis用作日志收集器, 多个端点将日志信息push到Redis,然后一个worker统一将所有日志写到磁盘rpop 3. 取最新N个数据的操作 记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。 把当前登录人添加到链表里 ret = r.lpush(\"login:last_login_times\", uid) 保持链表只有N位 ret = redis.ltrim(\"login:last_login_times\", 0, N-1) 获得前N个最新登陆的用户Id列表 last_login_list = r.lrange(\"login:last_login_times\", 0, N-1) 比如sina微博： 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。 但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。 只有在start/count参数超出了这个范围的时候，才需要去访问数据库。 我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了 列表类型（list） 内部使用双向链表实现，所以获取越接近两端的元素速度越快，但通过索引访问时会比较慢 添加左边元素：LPUSH 语法：LPUSH key value [value ...] ，返回添加后的列表元素的总个数 添加右边元素：RPUSH 语法：RPUSH key value [value ...] ，返回添加后的列表元素的总个数 移除左边第一个元素：LPOP 语法：LPOP key ，返回被移除的元素值 移除右边第一个元素：RPOP 语法：RPOP key ，返回被移除的元素值 列表元素个数：LLEN 语法：LLEN key， 不存在时返回0，redis是直接读取现成的值，并不是统计个数 获取列表片段：LRANGE 语法：LRANGE key start stop，如果start比stop靠后时返回空列表，0 -1 返回整个列表 正数时：start 开始索引值，stop结束索引值（索引从0开始） 负数时：例如 lrange num -2 -1，-2表示最右边第二个，-1表示最右边第一个， 删除指定值：LREM 语法：LREM key count value，返回被删除的个数 count>0，从左边开始删除前count个值为value的元素 count window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-set.html":{"url":"redis/redis-set.html","title":"2.2.5 set","keywords":"","body":"2.2.5 set集合基本操作 集合的概念就是一堆string类型且不重复值的无序的组合 说明：对于集合没有修改操作 Redis 中 集合是通过哈希表实现的，所以没有hash碰撞时添加，删除，查找的复杂度都是O(1),有碰撞时为O(n) 1 sadd key member1 member2 向集合添加一个或多个成员 2 smembers key 返回集合中的所有成员 3 srem key member1 member1 移除集合中一个或多个成员 4 sismember key member 判断 member 元素是否是集合 key 的成员 5 scard key 获取集合的成员数 6 sdiff key1 key2 返回给定所有集合的差集 7 sinter key1 key2 返回给定所有集合的交集 8 sunion key1 key2 返回所有给定集合的并集 使用场景: 交集，并集，差集 Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。 实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 一些会不重复的数据,进行交集,并集,差集等灵活操作抖音的关注人,粉丝,可分别放在一个set中 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。 Redis还为集合提供求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 //book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” //tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1 sadd tag:ruby 2 sadd tag:web 2 sadd tag:erlang 3 //即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") //即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") //属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") 获取某段时间所有数据去重值 这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。 集合类型（set） 集合类型值具有唯一性，常用操作是向集合添加、删除、判断某个值是否存在，集合内部是使用值为空的散列表实现的。 添加元素：SADD 语法：SADD key member [member ...] 向一个集合添加一个或多个元素，因为集合的唯一性，所以添加相同值时会被忽略。返回成功添加元素的数量。 删除元素：SREM 语法：SREM key member [member ...] 删除集合中一个或多个元素，返回成功删除的个数。 获取全部元素：SMEMBERS 语法：SMEMBERS key ，返回集合全部元素 值是否存在：SISMEMBER 语法：SISMEMBER key member ，如果存在返回1，不存在返回0 差运算：SDIFF 语法：SDIFF key [key ...] 例如：集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C 交运算：SINTER 语法：SINTER key [key ...]，返回交集集合，每个集合都有的元素 并运算：SUNION　语法：SUNION key [key ...]，返回并集集合，所有集合的元素 集合元素个数：SCARD 语法：SCARD key ，返回集合元素个数 集合运算后存储结果 语法：SDIFFSTROE destination key key2 ，差运算并存储到destination新集合中 SINTERSTROE destination key key2，交运算并存储到destination新集合中 SUNIONSTROE destination key [key ...]，并运算并存储到destination新集合中 随机获取元素：SRANDMEMGER 语法：SRANDMEMBER key [count] 根据count不同有不同结果，count大于元素总数时返回全部元素 count>0 ，返回集合中count不重复的元素 count window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-zset.html":{"url":"redis/redis-zset.html","title":"2.2.6 zset","keywords":"","body":"2.2.6 sorted set有序集合基本操作 redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复,当分数重复时,按照自然顺序排序。 明确存储对象用hash 指定存续的存储需顺序zset 需要添加循序指定 list sorted set常用操作命令如下 序号 命令 描述 1 zadd key score1 member1 score2 member2 向有序集合添加一个或多个成员，或者更新已存在成员的分数 2 zrange key start stop 返回指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0，索引可以是负数 表示从尾部开始计数，如-1表示最后⼀个元素 3 zcard key 获取有序集合的成员数 4 zscore key member 返回有序集中，成员的分数值 5 zcount key min max 计算在有序集合中指定区间权重的成员数 6 zrangebyscore key min max [withscores] [limit] 通过分数返回有序集合指定区间内的成员 7 zrank key member 返回有序集合中指定成员的索引 8 zrem key member member2 移除有序集合中的一个或多个成员 9 zincrby key increment member 有序集合中对指定成员的分数加上增量 increment 10 zinterstore destination numkeys key key2 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 11 zremrangebyscore key min max 移除有序集合中给定的分数区间的所有成员 12 zrevrangebyscore key max min [withscores] 返回有序集中指定分数区间内的成员，分数从高到低排序 13 zunionstore destination numkeys key key2 计算给定的一个或多个有序集的并集，并存储在新的 key 中 添加 zadd key score1 member1 score2 member2 zadd user 1 python 2 java 4 html 5 go 6 javascript 获取 zrange key start stop zrange user 1 -1 1) \"python\" 2) \"java\" 3) \"html\" 4) \"go\" 5) \"javascript\" 权重在min max 元素个数 zcount key min max zcount user 4 5 获取有序集合的成员数 zcard key zcard user 5 返回有序集中，成员的分数值 zscore key member zscore user java 2 通过分数返回有序集合指定区间内的成员 zrangebyscore key min max zrangebyscore user 3 6 1) \"html\" 2) \"go\" 3) \"javascript\" 返回有序集合中指定成员的索引 zrank key member zrank user java 2 zrank user 0 -1 1) \"python\" 2) \"java\" 3) \"html\" 4) \"go\" 5) \"javascript\" zrank user 0 -1 withscores 1) \"python\" 2) \"1\" 3) \"java\" 4) \"2\" 5) \"html\" 6) \"4\" 7) \"go\" 8) \"5\" 9) \"javascript\" 10) \"6\" 有序集合中对指定成员的分数加上增量 zincrby key increment member zincrby user 3 java 5 返回是权重 移除有序集合中的一个或多个成员 zrem key member zrem user python 使用场景: 使用场景：Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，插入时自动排序。 当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构, 比如twitter的public 微信朋友圈排序,分数用时间来表示, timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 经典案例:一个班的同学按分数排序,就可以把分数作为scored,实现排序 比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 sorted sorted特点: 有序， 元素string类型， 唯一性，不重复 每个元素都会关联double类型的score， 表示权重，通过权重将元素冲销到大排序， 元素的score可以重复 添加集合元素：zadd 添加集合元素：zadd key [nx|xx] [ch] [incr] score member [score member] 不存在添加，存在更新 获取元素分数：zscore 语法：zscore key member 返回元素成员的score 分数 元素小到大：zrange 语法：zrange key start top [withscores] 加上withscores 返回带元素，即元素，分数， 当分数一样时，按元素排序 元素大到小：zrevrange 语法：zrevrange key start [withscores] 指定分数范围元素：zrangebyscore 语法：zrangebyscore key min max [withscore] [limit offest count] 返回从小到大的在min和max之间的元素, 符号表示不包含，例如：80-100，(80 100，withscore返回带分数 limit offest count 向左偏移offest个元素，并获取前count个元素 指定分数范围元素：zrevrangescore 语法：zrevrangebyscore key max min [withscore] [limit offest count] 增加分数：zincrby 语法：zincrby key increment member 注意是增加分数，返回增加后的分数 如果成员不存在，则添加一个为0的成员 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-bitmaps.html":{"url":"redis/redis-bitmaps.html","title":"2.2.7 bitmaps","keywords":"","body":"2.2.7 BIgMap位图基本操作 位图：用每一位来存放某种状态，适用大规模数据，但数据状态有不是很多的情况 签到、点赞、取消点赞、查看是否点赞、统计一共多少点赞 1 setbit key member1 member2 向集合添加一个或多个成员 2 smembers key 返回集合中的所有成员 3 srem key member1 member1 移除集合中一个或多个成员 4 sismember key member 判断 member 元素是否是集合 key 的成员 5 scard key 获取集合的成员数 6 sdiff key1 key2 返回给定所有集合的差集 7 sinter key1 key2 返回给定所有集合的交集 8 sunion key1 key2 返回所有给定集合的并集 使用场景: 交集，并集，差集 Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。 实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 一些会不重复的数据,进行交集,并集,差集等灵活操作抖音的关注人,粉丝,可分别放在一个set中 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。 Redis还为集合提供求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 //book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” //tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1 sadd tag:ruby 2 sadd tag:web 2 sadd tag:erlang 3 //即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") //即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") //属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") 获取某段时间所有数据去重值 这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。 集合类型（set） 集合类型值具有唯一性，常用操作是向集合添加、删除、判断某个值是否存在，集合内部是使用值为空的散列表实现的。 添加元素：SADD 语法：SADD key member [member ...] 向一个集合添加一个或多个元素，因为集合的唯一性，所以添加相同值时会被忽略。返回成功添加元素的数量。 删除元素：SREM 语法：SREM key member [member ...] 删除集合中一个或多个元素，返回成功删除的个数。 获取全部元素：SMEMBERS 语法：SMEMBERS key ，返回集合全部元素 值是否存在：SISMEMBER 语法：SISMEMBER key member ，如果存在返回1，不存在返回0 差运算：SDIFF 语法：SDIFF key [key ...] 例如：集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C 交运算：SINTER 语法：SINTER key [key ...]，返回交集集合，每个集合都有的元素 并运算：SUNION　语法：SUNION key [key ...]，返回并集集合，所有集合的元素 集合元素个数：SCARD 语法：SCARD key ，返回集合元素个数 集合运算后存储结果 语法：SDIFFSTROE destination key key2 ，差运算并存储到destination新集合中 SINTERSTROE destination key key2，交运算并存储到destination新集合中 SUNIONSTROE destination key [key ...]，并运算并存储到destination新集合中 随机获取元素：SRANDMEMGER 语法：SRANDMEMBER key [count] 根据count不同有不同结果，count大于元素总数时返回全部元素 count>0 ，返回集合中count不重复的元素 count window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python.html":{"url":"redis/redis-python.html","title":"2.3. python-redis","keywords":"","body":"2.3 Redis应用场景 1、String 字符串 字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。 常用在缓存、计数、共享Session、限速等。 2、Hash 哈希 在Redis中，哈希类型是指键值本身又是一个键值对 结构， 形如value={{field1，value1}，…{fieldN，valueN}}， 添加命令：hset key field value。 哈希可以用来存放用户信息，比如实现购物车 3、List 列表 列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 另外，可以利用 lrange 命令，做基于 Redis的分页功能，性能极佳，用户体验好。 list是基于双向链表实现的，用于评论系统，新闻分页列表，消息队列等 4、Set 集合 集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是， 集合中不允许有重复元素，并且集合中的元素是无序的，不能通过 索引下标获取元素。 利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 5、Sorted Set 有序集合 Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。 可以做排行榜应用，取 TOP N 操作 6、BitMaps 用每一位来存放某种状态，适用大规模数据，但数据状态有不是很多的情况 签到、点赞、取消点赞、查看是否点赞、统计一共多少点赞 7、HyperLogLogs 使用HyperLogLog 解决海量数据统计问题 (统计用户访问量) HyperLogLogs 统计结果并不是完全精确，存在一定误差，对于精确度要求高的统计不适用 8、geospatial 记录地理位置的数据类型 微信定位 ,附近的人,打车距离计算 9、Streams window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-str.html":{"url":"redis/redis-python-str.html","title":"2.3.1 redis-str","keywords":"","body":"2.3.1 python操作redis之string字符串 # -*- coding: utf-8 -*- import redis #这个redis 连接不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") set 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。print r.set('123','123') # 插入成功后返回True print r.set('123','[123,dffd]') # 插入成功后返回True get 命令用于获取指定 key 的值。如果 key 不存在，返回 None 。如果key 储存的值不是字符串类型，返回一个错误。 print r.get('123') #返回的结果是[123,dffd] print r.get('1234')#返回的结果是 None getrange 命令用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。print r.set('getrange','wo shi hao ren ') print r.getrange('getrange',2,4) #返回的结果是sh print r.getrange('getrange',2,6) #返回的结果是shi print r.getrange('getrange',2,10) #返回的结果是shi hao getset 命令用于设置指定 key 的值，并返回 key 旧的值当 key 存在但不是字符串类型时，返回一个错误。print r.getset('getrange','hello word') #返回的结果是wo shi hao ren print r.getset('getrange11','hello word') #当键不存在的时候，返回的结果是None getbit 命令用于对 key 所储存的字符串值，获取指定偏移量上的位(bit)字符串值指定偏移量上的位(bit)。当偏移量 getrange 比字符串值的长度大，或者 key 不存在时，返回 0。 print r.get('getrange') #返回的结果是 hello word print r.getbit('getrange',1) #返回的结果是 1 print r.getbit('getrange',3) #返回的结果是 0 print r.getbit('getr22222ange',3) #字符串的键不存在的时候返回的结果是 0 print r.getbit('getrange',300) #偏移量超过字符串长度，返回的结果是 0 mget 命令返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 Noneprint r.set('1','1') #返回的结果是 True print r.set('11','11') #返回的结果是 True print r.set('111','111') #返回的结果是 True print r.mget('1','11','111') #返回的结果是 ['1', '11', '111'] print r.mget('1','11','222222') #因为键222222不存在，返回的结果是 ['1', '11', None] setbit 命令用于对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 print r.get('getrange') #返回的结果是 hello word print r.setbit('getrange',4,10086) #返回的结果是 1 print r.getbit('getrange',10086) #返回的结果是 0 print r.setbit('getrange',5,100861) #返回的结果是 0 print r.getbit('getrange',100861) #返回的结果是 0 setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， setex 命令将会替换旧的值。 print r.setex('1','123',10) #返回的结果是 True import time time.sleep(5) print r.ttl('1') #返回的结果是 4 print r.get('1') #返回的结果是 123 time.sleep(6) print r.get('1') #返回的结果是 None setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。设置成功，返回 1 。 设置失败，返回 0 。print r.exists('22') #返回的结果是 False print r.setnx('22','2222222') #返回的结果是 True print r.setnx('22','123456') #返回的结果是 False print r.get('22') #返回的结果是 2222222 setrange 命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。print r.set('11','hello world') #返回的结果是 True print r.setrange('11',6,\"redis\") #返回的结果是 11 print r.get('11') #返回的结果是 hello redis strlen 命令用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。print r.get('11') #返回的结果是 hello redis print r.strlen('11') #返回的结果是 11 print r.strlen('121') # 当key不存在的时候，返回的结果是 0 mset 命令用于同时设置一个或多个 key-value 对。第一种方法 print r.mset(name1=\"1\", name2='2') #返回的结果是 True 第二种方法 print r.mset({\"name3\":'3', \"name4\":'4'}) #返回的结果是 True print r.get('name1') #返回的结果是 1 print r.get('name2') #返回的结果是 2 print r.get('name3') #返回的结果是 3 print r.get('name4') #返回的结果是 4 metnx令用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对。 当所有 key 都成功设置，返回 1 。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。 print r.msetnx(name5=\"5\", name6='6') #返回的结果是 True print r.msetnx(name5=\"55\", name7='7') #返回的结果是 False print r.get('name5') #返回的结果是 5 print r.get('name6') #返回的结果是 6 print r.get('name7') #返回的结果是 None psetex 命令以毫秒为单位设置 key 的生存时间。注意：SETEX 命令那样，以秒为单位。print r.psetex('name8',1000,\"nihao\") #返回的结果是 True print r.pttl('name8') #返回的结果是 690 print r.get('name8') #返回的结果是 nihao 时间过期后返回的是 None Incr 命令将 key 中储存的数字值增一 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 本操作的值限制在 64 位(bit)有符号数字表示之内。print r.set('11',20) #返回的结果是 True print r.incr('11') #返回的结果是 21 print r.get('11') #返回的结果是 21 print r.incr('11',amount=2) #返回的结果是 23 print r.get('11') #返回的结果是 23 print r.incr('21',amount=2) #返回的结果是 2 print r.incr('22') #返回的结果是 1 Redis Incrby 命令将 key 中储存的数字加上指定的增量值。 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 print r.set(\"13\",13) #返回的结果是 True print r.incrby('13',12) #返回的结果是 25 print r.incrby('15',12) #返回的结果是 12 print r.incrby('15',12) #返回的结果是 24 Redis Incrbyfloat 命令为 key 中所储存的值加上指定的浮点数增量值。 如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。print r.set('1',1.1) #返回的结果是 True print r.incrbyfloat('1',2.32) #返回的结果是 3.42 print r.get('1') #返回的结果是 3.42 print r.incrbyfloat('1',amount=1.2) #返回的结果是 4.62 Redis Decr 命令将 key 中储存的数字值减一。 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 本操作的值限制在 64 位(bit)有符号数字表示之内。print r.decr('22') #如果 key 22 不存在，返回的结果是 -1 print r.set('bb',20) #返回的结果是 True print r.decr('bb',amount=2) #返回的结果是 18 print r.decr('cc') #返回的结果是 -1 Redis Append 命令用于为指定的 key 追加值。 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 print r.set(\"11\",12) #返回的结果是 True print r.append('11',12) #返回的结果是 4 print r.append('11',1) #返回的结果是 5 print r.append('11',2) #返回的结果是 6 print r.get('11') #返回的结果是 121212 print r.exists('14') #返回的结果是 False print r.append('14','hello world') #返回的结果是 11 print r.get('14') #返回的结果是 hello world 转载:[blackball9](https://www.cnblogs.com/blackball9/p/11970358.html) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-key.html":{"url":"redis/redis-python-key.html","title":"2.3.2 redis-key","keywords":"","body":"2.3.2 python操作redis之key键 # -*- coding: utf-8 -*- import redis #这个redis 连接不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") delete del命令用于删除已存在的键。不存在的 key 会被忽略 # set 设置指定 key 的值,如果设置正确返回 True print r.set('1', '4028b2883d3f5a8b013d57228d760a93') print r.get('1') # 得到 键为1 的值 4028b2883d3f5a8b013d57228d760a93 print r.delete('1') # 删除 键为1 的值 print r.get('1') # 因为上面已经把键为1 的值删除掉，所以返回的是None exists # 设定键为2的值是 4028b2883d3f5a8b013d57228d760a93 r.set('2', '4028b2883d3f5a8b013d57228d760a93') # 存在就返回True 不存在就返回False print r.exists('2') #返回True print r.exists('33') #返回False Expire 命令用于设置 key 的过期时间。key 过期后将不再可用。 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False，下面的20表示是20秒 print r.expire('2',20) #如果时间没事失效我们能得到键为2的值，否者是None print r.get('2') Expireat命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。注意:时间精确到秒，时间戳是10为数字 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False，下面的1598033936表示是在2020-08-22 02:18:56 键2 过期 print r.expireat('2',1598033936) print r.get('2') PEXPIREAT 命令用于设置 key 的过期时间，已毫秒技。key 过期后将不再可用。注意:时间精确到毫秒，时间戳是13位数字 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False。 print r.expireat('2',1598033936000) print r.get('2') Keys 命令用于查找所有符合给定模式 pattern 的 key print r.set('111', '11') print r.set('122', '12') print r.set('113', '13') print r.keys(pattern='11*') # 输出的结果是 ['113', '111'] 因为键122不和 11* 匹配 MOVE 命令用于将当前数据库的 key 移动到给定的数据库 db 当中,select可以设定当前的数据库，如有需要请看select命令因为我们默认使用的数据库是db0，我们可以使用下面的命令键 2 移动到数据库 1 中去 # 将select 0 key 为 2 转存到 select 1 r.move(2,1) PERSIST 命令用于移除给定 key 的过期时间，使得 key 永不过期 #设定键为 1 的值为11 print r.set('1', '11') #设定键 1 过期时间为100秒 print r.expire(1,100) # 查看键 1 的过期时间还剩下多少 print r.ttl('1') # 目的是13秒后移除键 1 的过期时间 import time time.sleep(3) # 查看键 1 的过期时间还剩下多少 print r.ttl('1') #移除键 1 的过期时间 r.persist(1) # 查看键 1 的过期时间还剩下多少 输出的结果是 None # 我们可以通过redis desktop manager 查看键 1 的过期时间 print r.ttl('1') Pttl 命令以毫秒为单位返回 key 的剩余过期时间。 # 当 key 不存在时，返回 -2 。 # 当 key 存在但没有设置剩余生存时间时，返回 -1 。 # 否则，以毫秒为单位，返回 key 的剩余生存时间。 #设定键为 1 的值为11 print r.set('1', '11') #设定键 1 过期时间为100秒 print r.expire(1,100) import time time.sleep(3) # 返回的结果是 96994 ，运行的结果不是固定的，大于是97秒钟， # 注意是为了展示出返回的结果是毫秒，一秒等于1000毫秒 print r.pttl('1') TTL 命令以秒为单位返回 key 的剩余过期时间。 # 当 key 不存在时，返回 -2 。 # 当 key 存在但没有设置剩余生存时间时，返回 -1 。 # 否则，以毫秒为单位，返回 key 的剩余生存时间。 # 设定键为 1 的值为11 print r.set('1', '11') # 设定键 1 过期时间为100秒 print r.expire(1,100) import time time.sleep(3) print r.ttl('1') #返回的结果是 97 print r.ttl('123') #因为键 123 不存在 所以返回的结果是None RANDOMKEY 命令从当前数据库中随机返回一个 key。当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。 print r.randomkey() # 数据库返回的是默认的数据库 key Rename 命令用于修改 key 的名称 。改名成功时提示 OK ，失败时候返回一个错误。 print r.rename(1,1111) #修改成功返回 True #如果key 不存在 修改失败返回 redis.exceptions.ResponseError: no such key print r.rename(222,1111) Renamenx 命令用于在新的 key 不存在时修改 key 的名称 。 print r.exists(123123) #返回false print r.renamenx(1111,123123) #成功返回True #失败返回 redis.exceptions.ResponseError: no such key print r.renamenx(1111,123123) Type 命令用于返回 key 所储存的值的类型 # 返回 key 的数据类型，数据类型有：none (key不存在)，string (字符串)，list (列表)，set (集合)，zset (有序集)，hash (哈希表)， print r.set('1',\"111111111\") print r.type('1') #返回的结果是string print r.sadd('2','222222222222') print r.type('2') #返回的结果是set print r.lpush('3','33333333') print r.type('3') #返回的结果是list 命令 描述 redis del 命令 该命令用于在 key 存在是删除 key。 redis dump 命令 序列化给定 key ，并返回被序列化的值。 redis exists 命令 检查给定 key 是否存在。 redis expire 命令 seconds 为给定 key 设置过期时间。 redis expireat 命令 expireat 的作用和 expire 类似，都用于为 key 设置过期时间。不同在于 expireat 命令接受的时间参数是 unix 时间戳(unix timestamp)。 redis pexpireat 命令 设置 key 的过期时间亿以毫秒计。 redis pexpireat 命令 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 redis keys 命令 查找所有符合给定模式( pattern)的 key 。 redis move 命令 将当前数据库的 key 移动到给定的数据库 db 当中。 redis persist 命令 移除 key 的过期时间，key 将持久保持。 redis pttl 命令 以毫秒为单位返回 key 的剩余的过期时间。 redis ttl 命令 以秒为单位，返回给定 key 的剩余生存时间(ttl, time to live)。 redis randomkey 命令 从当前数据库中随机返回一个 key 。 redis rename 命令 修改 key 的名称 redis renamenx 命令 仅当 newkey 不存在时，将 key 改名为 newkey 。 redis type 命令 返回 key 所储存的值的类型。   转载 blackball9 原文链接 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-hash.html":{"url":"redis/redis-python-hash.html","title":"2.3.3 redis-hash","keywords":"","body":"2.3.3 python操作redis之Hash哈希 # -*- coding: utf-8 -*- import redis #这个redis不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Hset 命令用于为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。 如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。 print r.hset(name=\"name\",key=\"key1\",value=\"value\") #返回的结果是 1 print r.hget(name=\"name\",key=\"key1\") #返回的结果是 value #返回的结果是 0,原因是哈希表中域字段已经存在且旧值已被新值覆盖 print r.hset(name=\"name\",key=\"key1\",value=\"hello world\") print r.hget(name=\"name\",key=\"key1\") #返回的结果是 hello world Hdel 命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.delete(1) # 删除成功后 返回的结果是 1 print r.delete(1) # 因为上一步已经删除，删除失败后 返回的结果是 0 Hexists 命令用于查看哈希表的指定字段是否存在。如果哈希表含有给定字段，返回 True 。 如果哈希表不含有给定字段，或 key 不存在，返回False 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hexists(name=\"1\",key=\"1\") # 返回的结果是 True print r.hexists(name=\"1\",key=\"2\") # 返回的结果是 False print r.hexists(name=\"2\",key=\"2\") # 返回的结果是 False print r.hexists(name=\"2\",key=\"1\") # 返回的结果是 False Hget 命令用于返回哈希表中指定字段的值。返回给定字段的值。如果给定的字段或 key 不存在时，返回 None 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hget(\"1\",\"1\") # 返回的结果是 1 print r.hget(\"2\",\"1\") # 因为字段2不存在。所以返回的结果是 None print r.hget(\"1\",\"2\") # 因为key 2 不存在。所以返回的结果是 None print r.hget(\"2\",\"2\") # 因为key和字段都不存在，所以返回的结果是 None Hgetall 命令用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。 print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"3\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"4\") # 返回的结果是 0 print r.hgetall(\"1\") # 返回的结果是 {'1': '1', '3': '2', '2': '4'} 主意返回的数据格式 print r.hgetall(\"2\") # 因为字典名2 不存在，所以返回的结果是 {} Hincrby 命令用于为哈希表中的字段值加上指定增量值。 增量也可以为负数，相当于对指定字段进行减法操作。 如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。 对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误。print r.hincrby(name=\"1\",key=\"1\",amount=2) # 返回的结果是 3 print r.hget(name=\"1\",key=\"1\") # 返回的结果是 3 print r.hincrby(name=\"2\", key=\"2\", value=\"3\") 字段不存在，返回的结果是 TypeError: hincrby() got an unexpected keyword argument 'value' print r.hincrby(name=\"1\",key=\"2\",amount=4) key为2不存在，返回的结果是 4，说明哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令 print r.hget(name=\"1\",key=\"2\") # 返回的结果是 4 Hincrbyfloat 命令用于为哈希表中的字段值加上指定浮点数增量值。 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hincrbyfloat(name=\"1\",key=\"1\",amount=\"1.2\") # 返回的结果是 2.2 print r.hget(\"1\",\"1\") # 返回的结果是 2.2 print r.hincrbyfloat(name=\"2\",key=\"1\",amount=\"1.2\") 指定的字段2不存在，返回的结果是 1.2，说明如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 Hkeys 命令用于获取哈希表中的所有字段名。包含哈希表中所有字段的列表。 当 key 不存在时，返回一个空列表。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"1\", value=\"2\") # 返回的结果是 0 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hkeys(1) # 返回的结果是 ['1', '2', '3'] print r.hkeys(2) # 因为指定的字段名不存在，所以返回的结果是 [] >Hlen 命令用于获取哈希表中字段的数量。哈希表中字段的数量。 当 key 不存在时，返回 0 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hlen(1) # 返回的结果是 2 print r.hset(name=\"1\", key=\"4\", value=\"3\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hlen(1) # 返回的结果是 4 Hmget 命令用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。 一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hmget(name=\"1\",keys=\"1\") # 返回的结果是 ['1'] print r.hmget(name=\"1\",keys=\"2\") # 返回的结果是['2'] print r.hmget(name=\"2\",keys=\"1\") # 返回的结果是 [None] Hmset 命令用于同时将多个 field-value (字段-值)对设置到哈希表中。 此命令会覆盖哈希表中已存在的字段。 如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作。aa = {\"a\":\"a\",\"b\":\"b\"} # 返回的结果是 ['1'] print r.hmset(\"name\",aa) # 返回的结果是 True print r.hget(name=\"name\",key=\"a\") # 返回的结果是 a print r.hget(name=\"name\",key=\"b\") # 返回的结果是 b Hsetnx 命令用于为哈希表中不存在的的字段赋值 。 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，操作无效。 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。 设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。print r.hsetnx(name=\"1\",key=\"1\",value=\"1\") # 返回的结果是 1 print r.hsetnx(name=\"1\",key=\"1\",value=\"2\") # 返回的结果是 0 print r.hsetnx(name=\"2\",key=\"1\",value=\"2\") # 返回的结果是 0 Hvals 命令返回哈希表所有字段的值。一个包含哈希表中所有值的表。 当 key 不存在时，返回一个空表。print r.hset(name=\"1\", key=\"1\", value=\"11\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"22\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"33\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"4\", value=\"44\") # 返回的结果是 1 print r.hvals(\"1\") # 返回的结果是 ['11', '22', '33', '44'] print r.hvals(\"2\") # 返回的结果是 [] 附录： 命令 描述 redis hdel 命令 删除一个或多个哈希表字段 redis hexists 命令 查看哈希表 key 中，指定的字段是否存在。 redis hget 命令 获取存储在哈希表中指定字段的值/td> redis hgetall 命令 获取在哈希表中指定 key 的所有字段和值 redis hincrby 命令 为哈希表 key 中的指定字段的整数值加上增量 increment 。 redis hincrbyfloat 命令 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 redis hkeys 命令 获取所有哈希表中的字段 redis hlen 命令 获取哈希表中字段的数量 redis hmget 命令 获取所有给定字段的值 redis hmset 命令 同时将多个 field-value (域-值)对设置到哈希表 key 中。 redis hset 命令 将哈希表 key 中的字段 field 的值设为 value 。 redis hsetnx 命令 只有在字段 field 不存在时，设置哈希表字段的值。 redis hvals 命令 获取哈希表中所有值 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-list.html":{"url":"redis/redis-python-list.html","title":"2.3.4 redis-list","keywords":"","body":"2.3.4 python操作redis之list列表 # -*- coding: utf-8 -*- import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Lpush 命令将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。 执行 LPUSH 命令后，列表的长度。 print r.lpush(\"1\",1) #输出的结果是1 print r.lpush(\"1\",1) #输出的结果是2 print r.lpush(\"1\",2,3,4) #输出的结果是5 print r.set(\"2\",1) #输出的结果是 True print r.lpush(\"2\",2) #输出的结果是 redis.exceptions.ResponseError: WRONGTYPE Operation against a key holding the wrong kind of value, 原因是键 2 是字符串类型，我们用list中的lpush给他添加元素 Rpush 命令用于将一个或多个值插入到列表的尾部(最右边)。 如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误。 执行 RPUSH 操作后，列表的长度。 print r.rpush(\"2\",1) #输出的结果是1 print r.rpush(\"2\",2,3) #输出的结果是3 print r.rpush(\"2\",4,5) #输出的结果是5 数据格式： Blpop 命令移出并获取列表的第一个元素 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 如果列表为空，返回一个 None 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 print r.rpush(\"3\",1,2,3,4,5,6,) #输出的结果是6 print r.blpop(\"3\") #输出的结果是('3', '1') print r.blpop(\"3\") #输出的结果是('3', '2') print r.blpop(\"3\") #输出的结果是('3', '3') print r.blpop(\"4\",timeout=2) #因为键 4 不存在，所以2秒后输出的结果是None Brpop 命令移出并获取列表的最后一个元素如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个None 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 print r.rpush(\"4\",1,2,3,4,5,6,) #输出的结果是6 print r.brpop(\"4\") #输出的结果是('4', '6') print r.brpop(\"4\") #输出的结果是('4', '5') print r.brpop(\"4\") #输出的结果是('4', '4') print r.brpop(\"5\",timeout=2) #因为键 4 不存在，所以2秒后输出的结果是None Brpoplpush 命令从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个 None 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。 print r.rpush(\"11\",1,2,3) #输出的结果是3 print r.rpush(\"22\",4,5,6,) #输出的结果是3 print r.brpoplpush(src=\"11\",dst=\"22\",timeout=2) #输出的结果是3 print r.brpoplpush(src=\"44\",dst=\"22\",timeout=2) #键44 不存在，输出的结果是None Lindex 命令用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回 None 。 print r.rpush(\"6\",1,2,3) #输出的结果是3 print r.lindex(\"6\",1) #输出的结果是2 print r.lindex(\"6\",2) #输出的结果是3 print r.lindex(\"6\",3) #输出的结果是None print r.lindex(\"6\",4) #输出的结果是None print r.lindex(\"6\",-1) #输出的结果是3 Linsert 命令用于在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。 如果命令执行成功，返回插入操作完成之后，列表的长度。如果没有找到指定元素 ，返回 -1 。如果 key 不存在或为空列表，返回 0 。 print r.rpush(\"7\",1) #输出的结果是1 print r.rpush(\"7\",2) #输出的结果是2 print r.linsert(\"7\",\"BEFORE\",\"2\",12) #输出的结果是2 Llen 命令用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。 print r.llen(\"8\") #key 不存在，输出的结果是0 print r.rpush(\"8\",1) #输出的结果是1 print r.llen(\"8\") #输出的结果是1 print r.rpush(\"8\",2,3) #输出的结果是3 print r.llen(\"8\") #输出的结果是3 Lpop 命令用于移除并返回列表的第一个元素。列表的第一个元素。 当列表 key 不存在时，返回 None 。 print r.lpop(\"9\") #输出的结果是None print r.rpush(\"9\",1) #输出的结果是1 print r.rpush(\"9\",2) #输出的结果是2 print r.lpop(\"9\") #输出的结果是1 说明：被移除掉的是第一个值 1, 值2没有被移除 Lpushx 将一个或多个值插入到已存在的列表头部，列表不存在时操作无效。 print r.rpush(\"10\",1) #输出的结果是1 print r.rpushx(\"10\",2) #输出的结果是2 print r.rpushx(\"10\",3) #输出的结果是3 print r.rpushx(\"11\",3) #输出的结果是5 print r.lrange(\"10\",0,-1) #输出的结果是['1', '2', '3'] print r.lrange(\"11\",0,-1) #输出的结果是['1', '2', '1', '2', '3'] Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 print r.rpush(\"11\",3,4) #输出的结果是4 print r.lrange(\"11\",0,-1) #输出的结果是['1', '2', '3', '4'] print r.lrange(\"11\",1,2) #输出的结果是['2', '3'] Lrem 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。 COUNT 的值可以是以下几种： count > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 count count = 0 : 移除表中所有与 VALUE 相等的值。 被移除元素的数量。 列表不存在时返回 0 。 print r.rpush(\"12\", 1) # 输出的结果是1 print r.rpush(\"12\", 1) # 输出的结果是2 print r.rpush(\"12\", 2) # 输出的结果是3 print r.rpush(\"12\", 1) # 输出的结果是4 print r.lrem(\"12\",1,-2) # 输出的结果是2 print r.lrange(\"12\",0,-1) # 输出的结果是['1', '2'] Lset 通过索引来设置元素的值。 当索引参数超出范围，或对一个空列表进行 LSET 时，返回一个错误 操作成功返回 True ，否则返回错误信息。print r.rpush(\"13\",1,2,3,4) # 输出的结果是4 print r.lset(\"13\",1,5) # 输出的结果是True print r.lrange(\"13\",0,-1) # 输出的结果是['1', '5', '3', '4'] Ltrim 对一个列表进行修剪(trim), 让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。print r.rpush(\"14\",1,2,3,4) # 输出的结果是4 print r.ltrim(\"14\",1,-2) # 输出的结果是True print r.lrange(\"14\",0,-1) # 输出的结果是['2', '3'] Rpop 命令用于移除并返回列表的最后一个元素。列表的最后一个元素。 当列表不存在时，返回 None 。print r.rpush(\"15\",1,2,3,4) # 输出的结果是4 print r.rpop(\"15\") # 输出的结果是4 print r.lrange(\"15\",0,-1) # 输出的结果是['1', '2', '3'] Rpoplpush 命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。print r.rpush(\"16\",1,2,3,4) # 输出的结果是4 print r.rpush(\"17\",1,2,3,4) # 输出的结果是4 print r.rpoplpush(\"16\",\"17\") # 输出的结果是4 print r.lrange(\"16\",0,-1) # 输出的结果是['1', '2', '3'] print r.lrange(\"17\",0,-1) # 输出的结果是['4', '1', '2', '3', '4'] Rpushx 命令用于将一个或多个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。print r.rpushx(\"18\",1) # 因为键18 不存在，所以插入失败，输出的结果是0 print r.rpush(\"18\",2) # 输出的结果是1 print r.rpushx(\"18\",3) # 输出的结果是2 print r.lrange(\"18\",0,-1) # 输出的结果是['2', '3'] 附录： 命令描述 redis blpop 命令 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis brpop 命令 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis brpoplpush 命令 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis lindex 命令 通过索引获取列表中的元素 redis linsert 命令 在列表的元素前或者后插入元素 redis llen 命令 获取列表长度 redis lpop 命令 移出并获取列表的第一个元素 redis lpush 命令 将一个或多个值插入到列表头部 redis lpushx 命令 将一个或多个值插入到已存在的列表头部 redis lrange 命令 获取列表指定范围内的元素 redis lrem 命令 移除列表元素 redis lset 命令 通过索引设置列表元素的值 redis ltrim 命令 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 redis rpop 命令 移除并获取列表最后一个元素 redis rpoplpush 命令 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 redis rpush 命令 在列表中添加一个或多个值 redis rpushx 命令 为已存在的列表添加值 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-set.html":{"url":"redis/redis-python-set.html","title":"2.3.5 redis-set","keywords":"","body":"2.3.5 python操作redis之set集合 -*- coding: utf-8 -*- import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。 假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。 print r.sadd(\"1\",1) #输出的结果是1 print r.sadd(\"1\",2) #输出的结果是1 print r.sadd(\"1\",2) #因为2已经存在，不能再次田间，所以输出的结果是0 print r.sadd(\"1\",3,4) #输出的结果是2 print r.sinter(\"1\") #输出的结果是set(['1', '3', '2', '4']) Scard 命令返回集合中元素的数量。集合的数量。当集合 key 不存在时，返回 0 。 print r.sadd(\"2\",1) #输出的结果是1 print r.sadd(\"2\",2,3,4,5) #输出的结果是4 print r.scard(\"2\") #输出的结果是5 Sdiff 命令返回给定集合之间的差集。不存在的集合 key 将视为空集。 print r.sadd(\"31\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"32\",4,5,6,7,8,9) #输出的结果是6 print r.sdiff(31,32) #输出的结果是set(['1', '3', '2']) 在31不在32内元素 print r.sdiff(32,31) #输出的结果是set(['9', '8', '7']) 在32不在31内元素 print r.sdiff(31,31) #输出的结果是set([]) Sdiffstore 命令将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。 print r.sadd(\"41\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"42\",4,5,6,7,8,9) #输出的结果是6 print r.sadd(\"43\",0) #输出的结果是1 print r.sdiffstore(\"43\",\"41\",\"42\") #输出的结果是3 覆盖原来的43的元素 print r.sinter(\"43\") #输出的结果是 set(['1', '3', '2']) Sinter 命令返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。 print r.sadd(\"51\",3,4,5,6) #输出的结果是4 print r.sadd(\"52\",1,2,3,4) #输出的结果是4 print r.sinter(51,52) #输出的结果是set(['3', '4']) print r.sadd(\"53\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"54\",3,4,5,6,7,8,9)#输出的结果是7 print r.sinter(53,54) #输出的结果是set(['3', '5', '4', '6']) print r.sinter(53,56) #输出的结果是set([]) Sinterstore 命令将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。 print r.sadd(\"61\",3,4,5,6) #输出的结果是4 print r.sadd(\"62\",1,2,3,4) #输出的结果是4 print r.sadd(\"63\",0) #输出的结果是1 print r.sinterstore(63,61,62) #输出的结果是2 print r.sinter(63) #输出的结果是set(['3', '4']) Sismember 命令判断成员元素是否是集合的成员。 如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。 print r.sadd(\"71\",1,2,3,4,5,6) #输出的结果是6 print r.sismember(\"71\",1) #输出的结果是True print r.sismember(\"71\",2) #输出的结果是True print r.sismember(\"71\",7) #输出的结果是False print r.sismember(\"71\",8) #输出的结果是False Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合。 print r.sadd(\"81\",1,2,3,4,5,6) #输出的结果是6 print r.smembers(81) #输出的结果是set(['1', '3', '2', '5', '4', '6']) print r.smembers(82) #输出的结果是set([]) Smove 命令将指定成员 member 元素从 source 集合移动到 destination 集合。 SMOVE 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 False 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。 当 source 或 destination 不是集合类型时，返回一个错误。 如果成员元素被成功移除，返回 True。 如果成员元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 False print r.sadd(\"91\",1,2,) #输出的结果是2 print r.sadd(\"92\",3,4,) #输出的结果是2 print r.smove(91,92,1) #把91中的1移动到92中去，输出的结果是True print r.smembers(\"91\") #输出的结果是set(['2']) print r.smembers(\"92\") #输出的结果是set(['1', '3', '4']) print r.smove(91,92,5) #91不存在5，输出的结果是False print r.smembers(\"91\") #输出的结果是set(['2']) print r.smembers(\"92\") #输出的结果是set(['1', '3', '4']) Spop 命令用于移除并返回集合中的一个随机元素。 print r.sadd(\"10\",1,2,3,4,5,6) #输出的结果是6 print r.spop(\"10\") #输出的结果是3 print r.smembers(\"10\") #输出的结果是set(['1', '2', '5', '4', '6']) print r.spop(\"10\") #输出的结果是1 print r.smembers(\"10\") #输出的结果是set(['2', '5', '4', '6']) Srandmember 命令用于返回集合中的一个随机元素。 从 Redis 2.6 版本开始， Srandmember 命令接受可选的 count 参数： 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。 该操作和 SPOP 相似，但 SPOP 将随机元素从集合中移除并返回，而 Srandmember 则仅仅返回随机元素，而不对集合进行任何改动。 print r.sadd(\"11\",1,2,3,4,5,6) #输出的结果是6 print r.srandmember(11) #输出的结果是4 print r.smembers(11) #输出的结果是set(['1', '3', '2', '5', '4', '6']) print r.srandmember(11,3) #输出的结果是['6', '3', '1'] print r.smembers(11) #输出的结果是set(['1', '3', '2', '5', '4', '6']) Srem 命令用于移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。 当 key 不是集合类型，返回一个错误。被成功移除的元素的数量，不包括被忽略的元素。 print r.sadd(\"12\",1,2,3,4,5,6,7) #输出的结果是7 print r.srem(\"12\",1) #输出的结果是1 print r.smembers(\"12\") #输出的结果是set(['3', '2', '5', '4', '7', '6']) print r.srem(\"12\",8) #输出的结果是0 print r.smembers(\"12\") #输出的结果是set(['3', '2', '5', '4', '7', '6']) Sunion 命令返回给定集合的并集。不存在的集合 key 被视为空集。 print r.sadd(\"131\",1,2,3,4,5,6,7) #输出的结果是7 print r.sadd(\"132\",0,1,2,7,8,9) #输出的结果是6 print r.sunion(131,132) #输出的结果是set(['1', '0', '3', '2', '5', '4', '7', '6', '9', '8']) print r.sunion(131,134) #输出的结果是set(['1', '3', '2', '5', '4', '7', '6']) Sunionstore 命令将给定集合的并集存储在指定的集合 destination 中。 print r.sadd(\"141\",1,2,3,4,5,6,7) #输出的结果是7 print r.sadd(\"142\",0,1,2,3,4) #输出的结果是5 print r.sunionstore(143,141,142) #输出的结果是8 print r.smembers(143) #输出的结果是set(['1', '0', '3', '2', '5', '4', '7', '6']) Sscan 命令用于迭代集合键中的元素。 print r.sadd(\"151\",1,2,3,4,5,6,7) #输出的结果是7 print r.sscan(151,cursor=2,match=1,count=1) #输出的结果是 (0L, ['1']) 附录： 命令描述 redis sadd 命令 向集合添加一个或多个成员 redis scard 命令 获取集合的成员数 redis sdiff 命令 返回给定所有集合的差集 redis sdiffstore 命令 返回给定所有集合的差集并存储在 destination 中 redis sinter 命令 返回给定所有集合的交集 redis sinterstore 命令 返回给定所有集合的交集并存储在 destination 中 redis sismember 命令 判断 member 元素是否是集合 key 的成员 redis smembers 命令 返回集合中的所有成员 redis smove 命令 将 member 元素从 source 集合移动到 destination 集合 redis spop 命令 移除并返回集合中的一个随机元素 redis srandmember 命令 返回集合中一个或多个随机数 redis srem 命令 移除集合中一个或多个成员 redis sunion 命令 返回所有给定集合的并集 redis sunionstore 命令 所有给定集合的并集存储在 destination 集合中 redis sscan 命令 迭代集合中的元素 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-zset.html":{"url":"redis/redis-python-zset.html","title":"2.3.6 redis-zset","keywords":"","body":"2.3.6 python操作redis之sorted set有序集合 #coding:utf8 import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。 分数值可以是整数值或双精度浮点数。 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。 当 key 存在但不是有序集类型时，返回一个错误。 print r.zadd(\"1\",\"1\",2,\"3\",3) #输出的结果是2 print r.zadd(\"1\",\"2\",2) #输出的结果是1 print r.zadd(\"1\",\"1\",1) #输出的结果是0 print r.zadd(\"1\",\"3\",4) #输出的结果是0 print r.zrange(\"1\",0,-1) #输出的结果是 ['1', '2', '3'] Zcard 命令用于计算集合中元素的数量。 当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。 print r.zadd(\"1\",\"1\",1,\"3\",3) #输出的结果是2 print r.zadd(\"1\",\"2\",2) #输出的结果是1 print r.zadd(\"1\",\"2\",4) #输出的结果是1 print r.zcard(1) #输出的结果是3 print r.zcard(2) #输出的结果是0 Zcount 命令用于计算有序集合中指定分数区间的成员数量。分数值在 min 和 max 之间的成员的数量。 print r.zadd(\"2\",\"1\",1,\"3\",3) #输出的结果是2 print r.zadd(\"2\",\"2\",2) #输出的结果是1 print r.zadd(\"2\",\"1\",4) #输出的结果是0 print r.zcount(\"2\",min=0,max=5) #输出的结果是3 print r.zcount(\"2\",min=0,max=3) #输出的结果是2 print r.zcount(\"2\",min=1,max=3) #输出的结果是2 Zincrby 命令对有序集合中指定成员的分数加上增量 increment 可以通过传递一个负数值 increment ，让分数减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。 当 key 不存在，或分数不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。 当 key 不是有序集类型时，返回一个错误。 分数值可以是整数值或双精度浮点数。 member 成员的新分数值，以字符串形式表示。 print r.zadd(\"4\",\"1\",1,\"2\",2,\"3\",3,\"4\",4) #输出的结果是4 print r.zincrby(name=4,value=1,amount=5) #输出的结果是6.0 print r.zincrby(name=4,value=2,amount=55) #输出的结果是57.0 print r.zrange(name=4,start=0,end=-1,withscores=False) #输出的结果是['1', '3', '2', '4'] Zinterstore 命令计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。 默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。 print r.zadd(\"41\", \"a1\", 6, \"a2\", 2,\"a3\",5) #输出的结果是3 print r.zadd('42', a1=7,b1=10, b2=5) #输出的结果是3 # 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作 # aggregate的值为: SUM MIN MAX print r.zinterstore(\"43\",(\"42\",\"41\"),aggregate=\"MAX\") #输出的结果是4 print(r.zscan(\"43\")) #输出的结果是(0L, [('a1', 7.0)]) Zlexcount 命令在计算有序集合中指定字典区间内成员数量。 print r.zadd(\"6\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zlexcount(name=6,min=\"-\",max=\"+\") #输出的结果是3 print r.zadd(\"6\", \"e\", 4, \"f\", 5,\"d\",6) #输出的结果是3 print r.zlexcount(name=6,min=\"-\",max=\"+\") #输出的结果是6 print r.zlexcount(name=6,min=\"[a\",max=\"[b\") #输出的结果是2 print r.zlexcount(name=6,min=\"[a\",max=\"[f\") #输出的结果是6 print r.zlexcount(name=6,min=\"[a\",max=\"[e\") #输出的结果是4 Zrange 返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。 如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。 print r.zadd(\"7\", \"1\", 1, \"2\", 2,\"3\",3,\"4\",4,\"5\",5) #输出的结果是5 print r.zrange(\"7\",start=0,end=-1,desc=False) #输出的结果是['1', '2', '3', '4', '5'] print r.zrange(\"7\",start=0,end=2,desc=False) #输出的结果是['1', '2', '3'] Zrangebylex 通过字典区间返回有序集合的成员。 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大 print r.zadd(\"8\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zrangebylex(name=\"8\",min=\"-\",max=\"[c\") #输出的结果是 ['a', 'b', 'c'] print r.zrangebylex(name=\"8\",min=\"-\",max=\"(c\") #输出的结果是 ['a', 'b'] print r.zadd(\"8\", \"e\", 4, \"f\", 5,\"d\",6) #输出的结果是3 print r.zrangebylex(name=8,min=\"[b\",max=\"[f\") #输出的结果是 ['b', 'c', 'e', 'f', 'd'] print r.zrangebylex(name=8,min=\"(b\",max=\"[f\") #输出的结果是 ['c', 'e', 'f', 'd'] Zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。 具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。 print r.zadd(\"9\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zrangebyscore(\"9\",\"1\",\"6\") #输出的结果是['a', 'b', 'c'] print r.zadd(\"9\", \"c\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrangebyscore(\"9\",\"3\",\"16\") #输出的结果是['c'] print r.zrangebyscore(\"9\",\"3\",\"36\") #输出的结果是['c', 'd', 'e'] Zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。 如果成员是有序集 key 的成员，返回 member 的排名。如果成员不是有序集 key 的成员，返回 None 。 print r.zadd(\"10\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"10\", \"f\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrank(\"10\",\"a\") #输出的结果是0 print r.zrank(\"10\",\"b\") #输出的结果是1 print r.zrank(\"10\",\"e\") #输出的结果是5 print r.zrank(\"10\",\"d\") #输出的结果是4 print r.zrank(\"10\",\"h\") #输出的结果是None Zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。 当 key 存在但不是有序集类型时，返回一个错误。 print r.zadd(\"11\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"11\", \"f\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrem(\"11\",\"a\") #输出的结果是1 print r.zrem(\"11\",\"f\") #输出的结果是1 print r.zrem(\"11\",\"h\") #输出的结果是0 print r.zrange(\"11\",start=0,end=32) #输出的结果是['b', 'c', 'd', 'e'], 其中a f已经移除掉 print r.zrange(\"11\",start=2,end=32) #输出的结果是['d','e'], 其中af已经移除掉，de没有被包涵 Zremrangebylex 命令用于移除有序集合中给定的字典区间的所有成员。 被成功移除的成员的数量，不包括被忽略的成员。 print r.zadd(\"12\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"12\", \"d\", 11, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebylex(\"12\",min=\"[a\",max=\"[c\") #输出的结果是3 print r.zrange(\"12\",0,-1) #输出的结果是 ['d', 'e', 'f'] 因为 a，b，c已经被移除 Zremrangebyrank 命令用于移除有序集中，指定排名(rank)区间内的所有成员。 print r.zadd(\"13\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"13\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebyrank(name=13,min=1,max=3) #输出的结果是3 print r.zrange(\"13\",\"0\",\"-1\") #输出的结果是['a', 'e', 'f'] 因为删除了 b，c，d Zremrangebyscore 命令用于移除有序集中，指定分数（score）区间内的所有成员。 print r.zadd(\"14\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"14\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebyscore(name=\"14\",min=\"1\",max=\"8\") #输出的结果是4,删除的a，b，c，d print r.zrange(name=\"14\",start=0,end=-1) #输出的结果是 ['e', 'f'] Zrevrange 命令返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。 除了成员按分数值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。 print r.zadd(\"15\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"15\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zrevrange(name=\"15\",start=0,end=-1) #输出的结果是['f', 'e', 'd', 'c', 'b', 'a'] print r.zrevrange(name=\"15\",start=1,end=21) #输出的结果是['e', 'd', 'c', 'b', 'a'] print r.zrevrange(name=\"15\",start=3,end=21) #输出的结果是['c', 'b', 'a'] Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。 除了成员按分数值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。 print r.zadd(\"16\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"16\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zrevrangebyscore(name=\"16\",max=33,min=0) #输出的结果是['f','e','d','c','b','a'] print r.zrevrangebyscore(name=\"16\",max=20,min=2) #输出的结果是['d', 'c', 'b'] Zrevrank 命令返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。 排名以 0 为底，也就是说， 分数值最大的成员排名为 0 。 使用 ZRANK 命令可以获得成员按分数值递增(从小到大)排列的排名。 print r.zadd(\"17\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"17\", \"d\", 4, \"e\", 5,\"f\",6) #输出的结果是3 print r.zrevrank(name=17,value=\"a\") #输出的结果是5 print r.zrevrank(name=17,value=\"c\") #输出的结果是3 print r.zrevrank(name=17,value=\"d\") #输出的结果是2 print r.zrevrank(name=17,value=\"h\") #输出的结果是None Zscore 命令返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 None 。print r.zadd(\"18\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"18\", \"d\", 4, \"e\", 5,\"f\",6) #输出的结果是3 print r.zscore(name=\"18\",value=\"a\") #输出的结果是1.0 print r.zscore(name=\"18\",value=\"c\") #输出的结果是3.0 print r.zscore(name=\"18\",value=\"f\") #输出的结果是6.0 print r.zscore(name=\"18\",value=\"h\") #输出的结果是None Zunionstore 命令计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。 默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。 保存到 destination 的结果集的成员数量。 Zscan 命令用于迭代有序集合中的元素（包括元素成员和元素分值） 返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。print r.zadd(\"20\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zscan(name=\"20\") #输出的结果是(0L, [('a', 1.0), ('b', 2.0), ('c', 3.0)]) print r.zadd(\"20\", \"d\", 4, \"e\", 5,\"f\",3) #输出的结果是3 print r.zscan(name=\"20\") #输出的结果是 (0L, [('a', 1.0), ('b', 2.0), ('c', 3.0), ('f', 3.0), ('d', 4.0), ('e', 5.0)]) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-hyperlog.html":{"url":"redis/redis-python-hyperlog.html","title":"2.3.7 redis-hyperlog","keywords":"","body":"2.3.7 python操作redis之HyperLogLog #coding:utf8 import redis # python 操作redis之——HyperLogLog r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Pfadd 命令将所有元素参数添加到 HyperLogLog 数据结构中。 print r.pfadd(\"1\",\"1\",\"2\") #输出结果是1 print r.pfadd(\"1\",\"3\",\"4\") #输出结果是1 print r.pfadd(\"1\",\"4\",\"5\") #输出结果是1 Pfcount 命令返回给定 HyperLogLog 的基数估算值。 print r.pfcount(\"1\") #输出结果是5, 因为 4 重复了两次 print r.pfcount(\"2\") #输出结果是0 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-example.html":{"url":"redis/redis-python-example.html","title":"2.3.8 应用示例","keywords":"","body":"2.3.8 python操作redis之应用示例 import redis from rediscluster import RedisCluster from config import ( REDIS_HOST, REDIS_PORT, REDIS_DB, REDIS_PASS, REDIS_CLUSTER ) class RedisDB(object): def __init__(self): self._pool = redis.ConnectionPool(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB, password=REDIS_PASS) self.conn = redis.Redis(connection_pool=self._pool) # ============redis list string======================= def set(self, key, value, expire=None): self.conn.set(key, value, expire) def get(self, key): return self.conn.get(key) def setex(self, key, expire_time, strval): return self.conn.setex(key, expire_time, strval) def expire(self, name, time): return self.conn.expire(name, time) def delete(self, name): self.conn.delete(name) # ============redis list hash============================== def hdel(self, name, key): return self.conn.hdel(name, key) def hset(self, name, key, value): self.conn.hset(name, key, value) def hget(self, key, fields): return self.conn.hget(key, fields) def hmset(self, key, fields): self.conn.hmset(key, fields) def hgetall(self, name): data = self.conn.hgetall(name) data = dict((item[0].decode('utf-8'), item[1].decode('utf-8')) for item in data.items()) if data else None return data def hvals(self, name): return self.conn.hvals(name) def hkeys(self, key): return self.conn.hkeys(key) def exists(self, key): return self.conn.exists(key) def hexists(self, name, key): return self.conn.hexists(name, key) # ============redis list queue====================== def qsize(self, name): return self.conn.llen(name) # 返回队列里面list内元素的数量 def put(self, name, values): self.conn.rpush(name, values) # 添加新元素到队列最右方 def get_wait(self, keys, timeout=None): # 返回队列第一个元素，如果为空则等待至有元素被加入队列（超时时间阈值为timeout，如果为None则一直等待） item = self.conn.blpop(keys, timeout=timeout) # if item: # item = item[1] # 返回值为一个tuple return item def get_nowait(self, name): # 直接返回队列第一个元素，如果队列为空返回的是None item = self.conn.lpop(name) return item # ============redis set ======================= def sismember(self, name, value): item = self.conn.sismember(name, value) return item my_redis = RedisDB() window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-python-strict.html":{"url":"redis/redis-python-strict.html","title":"2.3.9 Redis与StrictRedis区别","keywords":"","body":"2.3.8 python操作redis之redis.Redis与redis.StrictRedis区别 redis-py提供两个类Redis和StrictRedis用于实现Redis的命令 StrictRedis用于实现大部分官方的命令,并使用官方的语法和命令 Redis是StrictRedis的子类,用于向后兼容旧版本的redis-py。 官方推荐使用StrictRedis方法。Redis类和redis-cli操作有些不一样, 三个方面。 LREM:参数'num'和'value'的顺序交换了一下,cli是 lrem queueName 0 'string' , 0是所有 但是Redis这个类,把控制和string调换了。 ZADD:实现时score和value的顺序不小心弄反了,后来有人用了,就这样了 SETEX:time和value的顺序反了 Redis的连接池的方法: pool = redis.ConnectionPool(host='localhost', port=6379, db=0) r = redis.Redis(connection_pool=pool) StrictRedis的连接池的实现方式: pool = redis.ConnectionPool(host='127.0.0.1', port=6379) r = redis.StrictRedis(connection_pool=pool) 官方的创建redis的时候,都可以添加什么参数 class redis.StrictRedis( host='localhost', port=6379, db=0, password=None, socket_timeout=None, connection_pool=None, charset=‘utf-8’, errors=‘strict’, decode_responses=False, unix_socket_path=None ) Implementation of the Redis protocol. This abstract class provides a Python interface to all Redis commands and an implementation of the Redis protocol. Connection and Pipeline derive from this, implementing how the commands are sent and received to the Redis server redis的对于有些编码入库的问题,redis的连接附加的参数里面,默认编码是utf-8,但是如果你非要用GBK那就需要指明你的chardet和decode_responses为True 。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/reids-senior-problem.html":{"url":"redis/reids-senior-problem.html","title":"2.4. 应用场景","keywords":"","body":"常见问题 缓存击穿 缓存穿透 缓存雪崩 缓存预热 缓存降级 使用 分布式锁 秒杀库存预减 redis与mysql数据一致性问题 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-master-slave.html":{"url":"redis/redis-master-slave.html","title":"2.3.1 主从读分","keywords":"","body":"2.2.8 主从复制读写分类 本机给那台主机当从机 方法一 slaveof 主机ip 主机端口 slaveof 106.1234.608 6379 方法二 redis-server --slaveof 106.1234.608 6379 --masterauth 1qaz2wsx > redis.log & 方法三配置文件redis.conf slaveof 106.1234.608 6379 masterauth 1qaz2wsx 查看主从复制的信息 info replication 恢复主机身份，不给任何主机当从机 slaveof no one window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-application.html":{"url":"redis/redis-application.html","title":"2.3.2 应用场景","keywords":"","body":"2.2.7 Redis实际应用场景 一、Redis常用数据类型 Redis最为常用的数据类型主要有以下五种：String、Hash、List、Set、Sorted set 二、各种数据类型应用和实现方式 2.1 String String 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。 常用命令：get、set、incr、decr、mget等。 应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类，还可以享受Redis的定时持久化，操作日志及 Replication等功能， 还提供了下面一些操作： 获取字符串长度 往字符串append内容 设置和获取字符串的某一段内容 设置及获取字符串的某一位（bit） 批量设置一系列字符串的内容 使用场景：常规key-value缓存应用。常规计数: 微博数, 粉丝数。 实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。 2.2 Hash 常用命令：hget,hset,hgetall 等。 应用场景：我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式： ​ 第一种: 方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储 ​ 这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回， 并且修改操作需要对并发进行保护，引入CAS等复杂问题。 ​ 第二种:方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID作为唯一标识来取得对应属 性的值。这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据，但是如果内部Map的成 员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时， 而另其它客户端的请求完全不响应，这点需要格外注意。 使用场景：存储部分变更数据，如用户信息等。 实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储， 当成员数量增大时会自动转成真正的HashMap，此时encoding为ht 2.3 List 常用命令：lpush,rpush,lpop,rpop,lrange等 应用场景：Redis list的应用场景非常多，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。我们可以轻松地实现最新消息排行等功能 可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。 实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。 Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 使用场景： 消息队列系统,使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。 取最新N个数据的操作, 记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。 把当前登录人添加到链表里 ret = r.lpush(\"login:last_login_times\", uid) 保持链表只有N位 ret = redis.ltrim(\"login:last_login_times\", 0, N-1) 获得前N个最新登陆的用户Id列表 last_login_list = r.lrange(\"login:last_login_times\", 0, N-1) 比如sina微博： 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。 我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。 2.4 set 常用命令：sadd,spop,smembers,sunion 等。 应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Set数据结构，可以存储一些集合性的数据。 案例：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。 实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 使用场景：交集，并集，差集：(Set) book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1 sadd tag:ruby 2 sadd tag:web 2 sadd tag:erlang 3 即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") 即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") 属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") ​ 获取某段时间所有数据去重值，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。 2.5 Sorted Set 常用命令：zadd,zrange,zrem,zcard等 使用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 和Set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 实现方式： Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"redis/redis-scene.html":{"url":"redis/redis-scene.html","title":"2.3.3 应用场景","keywords":"","body":"2.2.7 Redis实际应用场景 1. 显示最新的项目列表 下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。 SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10 在Web应用中，\"列出最新的回复\"之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个\"显示全部\"的链接，点击后就可以获得更多的评论。我们假设数据库中的每条评论都有一个唯一的递增的ID字段。我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表： LPUSH latest.comments 我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论： LTRIM latest.comments 0 5000 每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）： FUNCTION get_latest_comments(start, num_items): id_list = redis.lrange(\"latest.comments\",start,start+num_items - 1) IF id_list.length 这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。 SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。 2. 排行榜应用，取TOP N操作 这个需求与上面需求的不同之处在于，取最新N个数据的操作以时间为权重，这个是以某个条件为权重比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。 热门，排行榜应用： //将登录次数和用户统一存储在一个 sorted set里zadd login:login_times 5 1zadd login:login_times 1 2zadd login:login_times 2 3 //当用户登录时，对该用户的登录次数自增 1ret = r.zincrby(\"login:login_times\", 1, uid) //那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户 ret = r.zrevrange(\"login:login_times\", 0, N-1) 另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要： 列出前100名高分选手 列出某用户当前的全球排名 这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。模式是这样的，每次获得新得分时，我们用这样的代码： ZADD leaderboard 你可能用userID来取代username，这取决于你是怎么设计的。得到前100名高分用户很简单： ZREVRANGE leaderboard 0 99 用户的全球排名也相似，只需要： ZRANK leaderboard 3. 删除与过滤 我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。 有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。 4. 按照用户投票和时间排序 排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：score = points / time^alpha 因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。 5. 处理过期项目 另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。 模式如下： 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。 6. 计数 Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。例如这样操作： INCR user: EXPIRE 你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。 7. 特定时间内的特定项目 另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。每次我获得一次新的页面浏览时我只需要这样做 SADD page:day1: 当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。 想知道特定用户的数量吗？只需要使用 SCARD page:day1: 8. 查找某个值所在的区间(区间无重合) Sorted Set-->例如有下面两个范围，10－20和30－40 A_start 10, A_end 20 B_start 30, B_end 40 我们将这两个范围的起始位置存在Redis的Sorted Sets数据结构中，基本范围起始值作为score，范围名加start和end为其value值： redis 127.0.0.1:6379> zadd ranges 10 A_start (integer) 1redis 127.0.0.1:6379> zadd ranges 20 A_end (integer) 1redis 127.0.0.1:6379> zadd ranges 30 B_start (integer) 1redis 127.0.0.1:6379> zadd ranges 40 B_end (integer) 1 这样数据在插入Sorted Sets后，相当于是将这些起始位置按顺序排列好了。现在我需要查找15这个值在哪一个范围中，只需要进行如下的zrangbyscore查找： redis 127.0.0.1:6379> zrangebyscore ranges (15 +inf LIMIT 0 1 1) \"A_end\" 这个命令的意思是在Sorted Sets中查找大于15的第一个值。（+inf在Redis中表示正无穷大，15前面的括号表示>15而非>=15）查找的结果是A_end，由于所有值是按顺序排列的，所以可以判定15是在A_start到A_end区间上，也就是说15是在A这个范围里。至此大功告成。 9. 交集，并集，差集：(Set) //book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” //tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1sadd tag:ruby 2sadd tag:web 2sadd tag:erlang 3 //即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") //即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") //属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/SUMMARY.html":{"url":"mongo/SUMMARY.html","title":"3.1 安装配置","keywords":"","body":"Summary Introduction window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongo-windos-install.html":{"url":"mongo/mongo-windos-install.html","title":"3.1.1 windos 安装","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongo-ubuntu-install.html":{"url":"mongo/mongo-ubuntu-install.html","title":"3.1.2 ubuntu 安装","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongo-centos-install.html":{"url":"mongo/mongo-centos-install.html","title":"3.1.3 centos 安装","keywords":"","body":"3.1.3 centos 之MongoDB 安装与配置 配置程序包管理系统 创建一个/etc/yum.repos.d/mongodb-org-4.4.repo文件，使用yum以下命令安装MongoDB [mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc 安装MongoDB软件包 sudo yum install -y mongodb-org /var/lib/mongo 数据目录 /var/log/mongodb 日志目录 /etc/yum.conf 配置文件 系统初始化服务 service mongod start 启动MongoDB chkconfig mongod on 系统重新启动 service mongod stop 停止MongoDB service mongod restart 重新启动MongoDB mongo 使用MongoDB mongo 172.16.0.13:27017/admin -u admin -p password sudo yum erase $(rpm -qa | grep mongodb-org) 删除软件包 sudo rm -r /var/log/mongodb 删除MongoDB数据库 sudo rm -r /var/lib/mongo 删除MongoDB日志文件 如果在启动时收到类似于以下内容的错误 mongod： Failed to start mongod.service: Unit mongod.service not found. 首先运行以下命令： sudo systemctl daemon-reload 然后再次运行上面的启动命令。 配置文件 systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log # Where and how to store data. storage: dbPath: /var/lib/mongo db目录 journal: enabled: true # engine: # wiredTiger: # how the process runs processManagement: fork: true 后台运行 pidFilePath: /var/run/mongodb/mongod.pid # location of pidfile timeZoneInfo: /usr/share/zoneinfo # network interfaces net: port: 27017 端口号（企业使用尽量不要用默认端口） bindIp: 0.0.0.0 #security: #operationProfiling: #replication: #sharding: ## Enterprise-Only Options #auditLog: window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongo-auth.html":{"url":"mongo/mongo-auth.html","title":"3.1.4 权限分配","keywords":"","body":"3.1.4 MongoDB 权限分配 mongo mongo 172.16.0.13:27017/admin -u admin -p password mongo -u 用户名 -p 密码 --port 端口号 --host IP 数据库名 mongo 192.168.0.1:27017/库名 -u 用户名 -p 密码 show dbs 查看库 use admin 使用某库 show users 查看用户 ``` 超级管理员 (用来管理用户的用户，可以通过超级管理员创建、删除用户 ) db.createUser({user:\"admin\",pwd:\"admin123456\",roles:[{role: \"userAdminAnyDatabase\", db: \"admin\"}]}) 超级管理员root( root角色用于关闭数据库 ) db.createUser({user: \"root\",pwd: \"password\", roles: [{role:\"root\", db: \"admin\" } ]}) 创建指定数据库testdb的用户，并且分配权限 use testdb db.createUser({user:'test',pwd:'test123',roles:[{role:'readWrite', db:'testdb'}]}) db.auth('test', 'test123') 修改权限、密码 use testdb db.createUser({user:'test',pwd:'test123',roles:[{role:'readWrite', db:'testdb'}]}) db.changeUserPassword('user','new password'); 删除账号 (删除用户必须由账号管理员来删) use admin db.auth(\"admin\",\"password\") db.system.users.remove({user:\"XXXXXX\"}) 删除单个用户 db.system.users.remove({}) 删除所有用户 注 [role] dbOwner owner权限 readWrite 读写权限 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongodb-mysql.html":{"url":"mongo/mongodb-mysql.html","title":"3.2 数据操作","keywords":"","body":"应用场景分析 一、 MySQL与MongoDB简单对比 存储方式 MySQL MongoDB 数据库模型 关系型 非关系型 存储方式 不同的引擎有不同的存储方式 虚拟内存+持久化 查询语句 传统的SQL语句 独特的MongoDB查询方式 架构特点 常见有单节点， M-S, MHA, MMM, cluster 等架构 通过副本集，以及分片来实现高可用 数据处理方式 不同的引擎有不同的特点 基于内存，将热数据存在物理内存中，从而达到高速读写 成熟度 拥有较为成熟的体系，成熟度较高 新型数据库，成熟度较低 广泛度 开源数据库的份额不断增加，MySQL份额也不短增加 Nosql数据库中，MongoDB较为完善，使用人数也不短增加 二、MongoDB优点 快速! 拥有适量级内存的Mongodb的性能是非常迅速的，它将热数据存储在物理内存中(而不仅仅是索引和少部分数据)，使得热数据的读写变得十分快速，从而提高了整体的速度与效率 高扩展性！Mongodb的高可用与集群架构拥有十分高的扩展性，通过物理机器的增加，以及sharding的增加，Mongodb的扩展将达到一个十分惊人的地步 自身的Failover机制！Mongodb的副本集配置中，当主库遇到问题，无法继续提供服务的时候，副本集将选举出一个新的主库来继续提供服务 Json的存储格式！Mongodb的Json与Bson存储格式十分适合文档格式的存储与查询。 三、MongoDB的应用场景 表结构不明确且数据不断变大 MongoDB是非结构化文档数据库，扩展字段很容易且不会影响原有数据。 内容管理或者博客平台等 例如圈子系统，存储用户评论之类的 更高的写入负载 MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。 本身存的就是json格式数据 例如做日志系统 数据量很大或者将来会变得很大 Mysql单表数据量达到5-10G时会出现明细的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展 MongoDB内建了sharding、很多数据分片的特性，容易水平扩展，比较好的适应大数据量增长的需求。 高可用性 自带高可用，自动主从切换（副本集） 不适用的场景 MongoDB不支持事务操作，需要用到事务的应用建议不用MongoDB MongoDB目前不支持join操作，需要复杂查询的应用也不建议使用MongoDB 四、关系型数据库和非关系型数据库的应用场景对比 关系型数据库适合存储结构化数据，如用户的帐号、地址 1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹 2）这些数据的规模、增长的速度通常是可以预期的 3）事务性、一致性 NoSQL适合存储非结构化数据，如文章、评论： 1）这些数据通常用于模糊处理，如全文搜索、机器学习 2）这些数据是海量的，而且增长的速度是难以预期的， 3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性 4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差 五、MySQL与MongoDB在使用时又该如何去选择呢 相比较MySQL，MongoDB数据库更适合那些读作业较重的任务模型 MongoDB能充分利用机器的内存资源。如果机器的内存资源丰富的话，MongoDB的查询效率会快很多 相比MongoDB，MySQL数据库更适合插入、更新为主的任务模型，其效率相比于MongoDB优势非常明显 在带”_id”插入数据的时候，MongoDB的插入效率其实并不高 如果想充分利用MongoDB性能的话，推荐采取不带”_id”的插入方式，然后对相关字段作索引来查询。 MongoDB适合那些对数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，而且对开发者十分友好 MongoDB用之前不用想太多；而MySQL使用之前，必须提前建库建表，并明确数据的具体格式，约束较大。 稳定性方面，MongoDB不如MySQL MySQL是一种非常稳定的数据库，无论在指定主键还是在不指定主键插入的情况下，其效率都差不了太多, 其稳定性可以说是毋庸置疑的 事务支持方面，MySQL占绝对优势，MongoDB对事务关系支持薄弱 事务可以说是所有NoSQL数据库共同的缺陷，不过NoSQL并不是为了事务关系而设计的，具体应用还是很需求 参考文章 mongoDB和mysql对比分析及选 https://www.cnblogs.com/1488boss/p/10754290.html 其它 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongodb-grammar.html":{"url":"mongo/mongodb-grammar.html","title":"3.2.1 数据操作","keywords":"","body":"MongoDB的操作 一、mongo 与mysql 术语对比 MySQL MongoDB 解释/说明 database database 数据库 table collections 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins - 表链接， MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 二、 Mysql与MongoDB操作命令对比 三、 mongodb 增删改查操作 比较运算符号 比较运算符号 $lt 小于 $gt 大于 $lte 小于等于 $gte 大于等于 $ne 不等于 - - window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongodb-index.html":{"url":"mongo/mongodb-index.html","title":"3.2.2 索引部分","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongodb-export.html":{"url":"mongo/mongodb-export.html","title":"3.2.3 导入导出","keywords":"","body":"MongoDB 数据的批量备份、还原、导入与导出 mongodb数据备份和还原主要分为二种，一种是针对于库的mongodump和mongorestore，一种是针对库中表的mongoexport和mongoimport。 一、mongodump备份数据库 1.常用命令格 mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 如果没有用户谁，可以去掉-u和-p。 如果导出本机的数据库，可以去掉-h。 如果是默认端口，可以去掉–port。 如果想导出所有数据库，可以去掉-d。 2. 导出所有数据库 [root@localhost mongodb]$ mongodump -h 127.0.0.1 -o /usr/local/Cellar/mongodb connected to: 127.0.0.1 Tue Dec 3 06:15:55.448 all dbs Tue Dec 3 06:15:55.449 DATABASE: test to /usr/local/Cellar/mongodb/test Tue Dec 3 06:15:55.449 test.system.indexes to /home/zhangy/mongodb/test/system.indexes.bson Tue Dec 3 06:15:55.450 1 objects Tue Dec 3 06:15:55.450 test.posts to /usr/local/Cellar/mongodb/test/posts.bson Tue Dec 3 06:15:55.480 0 objects 3. 导出指定数据库 [root@localhost mongodb]$ mongodump -h 192.168.1.108 -d tank -o /home/zhangy/mongodb/ connected to: 192.168.1.108 Tue Dec 3 06:11:41.618 DATABASE: tank to /usr/local/Cellar/mongodb/tank Tue Dec 3 06:11:41.623 tank.system.indexes to /usr/local/Cellar/mongodb/tank/system.indexes.bson Tue Dec 3 06:11:41.623 2 objects Tue Dec 3 06:11:41.623 tank.contact to /usr/local/Cellar/mongodb/tank/contact.bson Tue Dec 3 06:11:41.669 2 objects Tue Dec 3 06:11:41.670 Metadata for tank.contact to /usr/local/Cellar/mongodb/tank/contact.metadata.json Tue Dec 3 06:11:41.670 tank.users to /usr/local/Cellar/mongodb/tank/users.bson Tue Dec 3 06:11:41.685 2 objects Tue Dec 3 06:11:41.685 Metadata for tank.users to /usr/local/Cellar/mongodb/tank/users.metadata.json 二、mongorestore还原数据库 1. 常用命令格式 mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径 -- drop的意思是，先删除所有的记录，然后恢复。 2. 恢复所有数据库到mongodb中 [root@localhost mongodb]$ mongorestore /usr/local/Cellar/mongodb/ # 这里的路径是所有库的备份路径 3. 还原指定的数据库 [root@localhost mongodb]$ mongorestore -d tank /usr/local/Cellar/mongodb/tank/ # tank这个数据库的备份路径 [root@localhost mongodb]$ mongorestore -d tank_new /usr/local/Cellar/mongodb/tank/ # 将tank还有tank_new数据库中 这二个命令，可以实现数据库的备份与还原，文件格式是json和bson的。无法指写到表备份或者还原。 三、mongoexport导出表，或者表中部分字段 命令简拼 d db 数据库 c collection 集合 f fields 字段 type type 文件格式 o out 导出路径及文件名 q 查询条件 -q '{ \"uid\" : \"100\" }' 导出uid为100的数据 ------------ -------- --------------------------------------------- upsert 插入更新 插入或者更新现有数据(还原整表导出的非csv文件) drop 删除 先删除所有的记录，然后恢复 upsertFields 插入更新 插入或者更新现有数据(还原部分字段的导出文件) 1. 常用命令格式 mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名 2. 导出整张表 [root@localhost mongodb]# mongoexport -d tank -c users -o /home/zhangy/mongodb/tank/users.dat connected to: 127.0.0.1 exported 4 records 3. 导出表中部分字段 [root@localhost mongodb]# mongoexport -d tank -c users --csv -f uid,name,sex -o tank/users.csv mongoexport --db db_name --collection collection_name --type=csv --fields title,link,publish,read --out ~/Desktop/posts.csv 4. 根据条件敢出数据 [root@localhost mongodb]# mongoexport -d tank -c users -q '{uid:{$gt:1}}' -o tank/users.json 四、mongoimport导入表，或者表中部分字段 1.1. 还原整表导出的非csv文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 1.2. 还原部分字段的导出文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名 1.3. 还原导出的csv文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名 1.4 上面三种情况，还可以有其他排列组合的 1.5 还原导出的表数据 [root@localhost mongodb]$ mongoimport -d tank -c users --upsert tank/users.dat connected to: 127.0.0.1 Tue Dec 3 08:26:52.852 imported 4 objects 1.6 部分字段的表数据导入 [root@localhost mongodb]$ mongoimport -d tank -c users --upsertFields uid,name,sex tank/users.dat connected to: 127.0.0.1 Tue Dec 3 08:31:15.179 imported 4 objects 1.7 还原csv文件 [root@localhost mongodb]$ mongoimport -d tank -c users --type csv --headerline --file tank/users.csv connected to: 127.0.0.1 Tue Dec 3 08:37:21.961 imported 4 objects 转载:海底苍鹰地址:http://blog.51yip.com/nosql/1573.html window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/pymongo.html":{"url":"mongo/pymongo.html","title":"3.3 pymongo","keywords":"","body":"mongodb和python交互 一、安装 pymongo 提供了mongdb和python交互的所有方法 安装方式: pip install pymongo 二、连接及建库-创表-数据的 使用pymongo的第一步首先是连接Client来使用服务，my_db是数据库名称，如果没有会自动创建 3.1.1 无需权限认证的方式创建连接对象以及集合操作对象 from pymongo import MongoClient client = MongoClient(host,port) collection = client[db名][集合名] # collection = client.my_db 名.集合名 # 与上边用法相同 3.1.2 需要权限认证的方式创建连接对象以及集合操作对象 from pymongo import MongoClient user = 'python' password = 'python' host = '127.0.0.1' port = 27017 uri = \"mongodb://%s:%s@%s\" % (user, password, host) # uri = mongodb://python:python@127.0.0.1 client = MongoClient(uri, port=port) collection = client.my_db 名.集合名 3.1.3查看数据库下所有表名 collection.collection_names() 三、新增数据 3.3.1 insert() 添加一条数据，返回插入数据的_id ret = collection.insert({\"name\":\"zhangsan\",\"age\":33}) 3.3.2 insert() 添加多条数据，返回ObjectId对象构成的列表 item_list = [{\"name\":\"张{}疯\".format(i)} for i in range(10)] rets = collection.insert(item_list) 3.3.3 insert_one() 插入单个数据 collection.insert_one({\"key1\":\"value1\",\"key2\",\"value2\"}) 3.3.4 insert_many()插入多个数据 new_document = [{\"key1\":\"value1\",\"key2\",\"value2\"}] result = collection.insert_many(new_document) 四、删除数据 3.4.1 delete_one() 删除一条数据 collection.delete_one({\"name\":\"张三疯\"}) 3.4.2 delete_many() 删除全部数据 collection.delete_many({\"name\":\"张三疯\"}) collection.delete_many({}) 删除全部 五、更新数据 3.5.0 update()更新数据(全文档覆盖或指定键值，更新一条或多条) 语法：collection.update({条件}, {'$set':{指定的kv或完整的一条数据}}, multi=False/True, upsert=False/True) multi参数：默认为False,表示更新一条; multi=True则更新多条; multi参数必须和$set一起使用 upsert参数：默认为False; upsert=True则先查询是否存在,存在则更新;不存在就插入 $set表示指定字段进行更新 3.5.1 更新一条数据；全文档覆盖；存在就更新，不存在就插入 data = {'msg':'这是一条完整的数据1','name':'哈哈'} collection.update({'haha': 'heihei'}, {'$set':data}, upsert=True) 3.5.2 更新多条数据；全文档覆盖；存在就更新，不存在就插入 data = {'msg':'这是一条完整的数据2','name':'哈哈'} # 该完整数据是先查询后获取的 collection.update({}, {'$set':data}, multi=True, upsert=True) 3.5.3 更新一条数据；指定键值；存在就更新，不存在就插入 data = {'msg':'指定只更新msg___1'} collection.update({}, {'$set':data}, upsert=True) 3.5.4 更新多条数据；指定键值；存在就更新，不存在就插入 data = {'msg':'指定只更新msg___2'} collection.update({}, {'$set':data}, multi=True, upsert=True) 六、 查询数据 3.6.1 find_one()查找一条数据 接收一个字典形式的条件，返回字典形式的整条数据 如果条件为空，则返回第一条 ret = collection.find_one({'name': 'test10001'}) print(ret) # 包含mongodb的ObjectId对象的字典 _ = ret.pop('_id') # 清除mongodb的ObjectId对象的k,v print(ret) 2.6.2 find()查找全部数据 返回所有满足条件的结果，如果条件为空，则返回全部 结果是一个Cursor游标对象，是一个可迭代对象，可以类似读文件的指针，但是只能够进行一次读取 rets = collection.find({\"name\":\"test10005\"})， for ret in rets: print(ret) 3.6.3 获取数据总数 print(collection.find().count()) 3.6.4 查询结果排序 collection.find().sort(\"key1\") # 默认为升序 collection.find().sort(\"key1\", pymongo.ASCENDING) # 升序 collection.find().sort(\"key1\", pymongo.DESCENDING) # 降序 pymongo模块其他api 查看pymongo官方文档或源代码 http://api.mongodb.com/python/current/ window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongoengine.html":{"url":"mongo/mongoengine.html","title":"3.4 mongoengine","keywords":"","body":" window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongoengine-connect.html":{"url":"mongo/mongoengine-connect.html","title":"3.4.1 链接方式","keywords":"","body":"2.2 connect MongoDB 一、链接到MongoDB 方式一 from mongoengine import connect connect('project1', host='192.168.1.35', port=12345) 方式二 from mongoengine import connect connect('project1', host='192.168.1.35', port=12345) 方式三 from mongoengine import connect connect('project1', host='mongodb://localhost/database_name') 方式四 from mongoengine import connect connect('project1', username='webapp', password='pwd123', authentication_source='admin') 方式五 URI字符串中的数据库，用户名和密码会覆盖以下参数connect() from mongoengine import connect connect( db='test', username='user', password='12345', host='mongodb://admin:qwerty@localhost/production' ) 二、Replica Sets MongoEngine连接到副本集 from mongoengine import connect # Regular connect connect('dbname', replicaset='rs-name') # MongoDB URI-style connect connect(host='mongodb://localhost/dbname?replicaSet=rs-name') 通过连接或通过传递read_preference的单个查询支持读取首选项 Bar.objects().read_preference(ReadPreference.PRIMARY) Bar.objects(read_preference=ReadPreference.PRIMARY) 三、内容管理 有时您可能想要切换数据库或集合以进行查询。例如，出于性能原因将较旧的数据归档到单独的数据库中，或者编写可动态选择要向其写入文档的集合的函数 在不同数据库中定义的文档，通过在元数据中提供db_alias，可以将各个文档附加到不同的数据库 。这使DBRef 对象可以指向数据库和集合。下面是一个示例架构，使用3个不同的数据库来存储数据： connect(alias='user-db-alias', db='user-db') connect(alias='book-db-alias', db='book-db') connect(alias='users-books-db-alias', db='users-books-db') class User(Document): name = StringField() meta = {'db_alias': 'user-db-alias'} class Book(Document): name = StringField() meta = {'db_alias': 'book-db-alias'} class AuthorBooks(Document): author = ReferenceField(User) book = ReferenceField(Book) meta = {'db_alias': 'users-books-db-alias'} 断开现有连接 该功能disconnect()可用于断开特定连接。这可用于全局更改连接： from mongoengine import connect, disconnect connect('a_db', alias='db1') class User(Document): name = StringField() meta = {'db_alias': 'db1'} disconnect(alias='db1') connect('another_db', alias='db1') 切换数据库 该switch_db 上下文管理器允许您更改数据库别名给定类，允许快速和方便地访问跨数据库相同的用户文档： from mongoengine.context_managers import switch_db class User(Document): name = StringField() meta = {'db_alias': 'user-db'} with switch_db(User, 'archive-user-db') as User: User(name='Ross').save() # Saves the 'archive-user-db' 开关集合 该switch_collection()上下文管理器允许您更改集合给定类，允许快速和方便地访问整个集合在同一组的文件： from mongoengine.context_managers import switch_collection class Group(Document): name = StringField() Group(name='test').save() # Saves in the default db with switch_collection(Group, 'group2000') as Group: Group(name='hello Group 2000 collection!').save() # Saves in group2000 collection window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongoengine-documents.html":{"url":"mongo/mongoengine-documents.html","title":"3.4.2 model","keywords":"","body":"3.3.2 模型架构 一、模型架构 from mongoengine import * import datetime SIZE = ( ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ('XL', 'Extra Large'), ('XXL', 'Extra Extra Large') ) def _not_empty(val): if not val: raise ValidationError('value can not be empty') class Page(Document): title = StringField(max_length=200, required=True) date_modified = DateTimeField(default=datetime.datetime.utcnow) values = ListField(IntField(), default=list) values = ListField(IntField(), default=lambda: [1,2,3]) values = ListField(IntField(), default=[1,2,3]) size = StringField(max_length=3, choices=SIZE) name = StringField(validation=_not_empty) 二、字段类型 字段 说明 字段 说明 BinaryField 二进制 ImageField 图像 BooleanField IntField ComplexDateTimeField 复杂日期时间 ListField 列表 DateTimeField 日期时间域 LongField DecimalField MapField DictField ObjectIdField 对象 DynamicField [动态] ReferenceField 参考 EmailField 电子邮件 LazyReferenceField 懒散参考 EmbeddedDocumentField [嵌入文档] SequenceField 序列 EmbeddedDocumentListField [嵌入文档列表] SortedListField 排序列表 EnumField 枚举 StringField 字符串 FileField 文件 URLField URL FloatField 浮点数 UUIDField GenericEmbeddedDocumentField [通用嵌入文档] PointField GenericReferenceField [通用参考字段] LineStringField 线串 GenericLazyReferenceField 通用惰性引用字段 PolygonField 多边形 GeoPointField 地理点 MultiPointField 多点 Geo Point Field 图像 MultiLineStringField 多行字符串 MultiPolygonField 三、字段参数 强制性：required=True 默认值：False 约束性：max_length 默认值：default 唯一性：unique 主键：primary_key， 如设置也可以通过pk字段访问 可选择迭代：choices 例如列表，元组或集合 其他:unique_with validation 可调用以验证字段的值。可调用对象将值作为参数，如果验证失败，则应引发ValidationError **kwargs（可选的） 您可以提供其他元数据作为任意其他关键字参数。但是，您不能覆盖现有属性。常见选择包括help_text和verbose_name，它们通常由表单和窗口小部件库使用。 四、字段类型 List fields列表字段： 将另一个字段对象作为其第一个参数，它指定可以在列表中存储哪些类型的元素 class Page(Document): tags = ListField(StringField(max_length=50)) 嵌入式文件Embedded documents 可以将文档嵌入其他文档中。可以为这些嵌入式文档定义图式，就像为常规文档定义图式一样。要创建嵌入式文档，只需照常定义一个文档，但要继承自EmbeddedDocument而不是 class Comment(EmbeddedDocument): content = StringField() 要将文档嵌入另一个文档中，使用EmbeddedDocumentField字段类型，将嵌入式文档类作为第一个参数： class Page(Document): comments = ListField(EmbeddedDocumentField(Comment)) comment1 = Comment(content='Good work!') comment2 = Comment(content='Nice article!') page = Page(comments=[comment1, comment2]) Dictionary Fields 通常，可以使用嵌入式文档代替字典-通常建议使用嵌入式文档，因为字典不支持验证或自定义字段类型。但是，有时您可能不知道要存储的内容的结构。在这种情况下，DictField是合适的： class SurveyResponse(Document): date = DateTimeField() user = ReferenceField(User) answers = DictField() survey_response = SurveyResponse(date=datetime.utcnow(), user=request.user) response_form = ResponseForm(request.POST) survey_response.answers = response_form.cleaned_data() survey_response.save() 可以存储复杂的数据，其他字典，列表，对其他对象的引用，因此可以存储最灵活的字段类型 Reference fields 引用可以使用来存储到数据库中的其他文档ReferenceField。将另一个文档类作为第一个参数传递给构造函数，然后只需将文档对象分配给该字段： class User(Document): name = StringField() class Page(Document): content = StringField() author = ReferenceField(User) john = User(name=\"John Smith\") john.save() post = Page(content=\"Test Page\") post.author = john post.save() 该User对象将自动转换为幕后参考，并在Page检索到对象时取消引用。 要添加ReferenceField引用正在定义的文档的，请使用字符串self代替文档类作为ReferenceField构造函数的参数。要引用尚未定义的文档，请使用未定义文档的名称作为构造函数的参数： class Employee(Document): name = StringField() boss = ReferenceField('self') profile_page = ReferenceField('ProfilePage') class ProfilePage(Document): content = StringField() ListFields一对多 如果要通过引用列表实现一对多关系，则引用将存储为DBRef，要查询您需要将对象的实例传递给查询： class User(Document): name = StringField() class Page(Document): content = StringField() authors = ListField(ReferenceField(User)) bob = User(name=\"Bob Jones\").save() john = User(name=\"John Smith\").save() Page(content=\"Test Page\", authors=[bob, john]).save() Page(content=\"Another Page\", authors=[john]).save() # 查找Bob编写的所有页面 Page.objects(authors__in=[bob]) # 找到鲍勃和约翰都写过的所有网页 Page.objects(authors__all=[bob, john]) # 将Bob从作者处删除一页 Page.objects(id='...').update_one(pull__authors=bob) # 给作者加上约翰一页。 Page.objects(id='...').update_one(push__authors=john) 处理引用文件的删除 默认情况下，MongoDB不会检查数据的完整性，因此删除其他文档仍保留引用的文档将导致一致性问题。Mongoengine的ReferenceField功能增加了一些功能，可防止此类数据库完整性问题，并为每个引用提供了删除规则规范。通过reverse_delete_rule在ReferenceField定义中提供属性 来指定删除规则，如下所示： class ProfilePage(Document): ... employee = ReferenceField('Employee', reverse_delete_rule=mongoengine.CASCADE) 在此示例中的声明意味着，当Employee删除一个对象时ProfilePage，引用该雇员的对象也将被删除。如果删除了整批员工，则所有链接的个人资料页也会被删除。 其值可以采用以下任何常量： mongoengine.DO_NOTHING 这是默认设置，不会执行任何操作。删除速度很快，但是可能导致数据库不一致或引用悬挂。 mongoengine.DENY 如果仍然存在要删除的对象的引用，则拒绝删除。 mongoengine.NULLIFY 任何仍引用要删除的对象的对象字段都设置为None（使用MongoDB的“ unset”操作），从而有效地消除了关系。 mongoengine.CASCADE 首先删除包含引用要删除的对象的字段的任何对象。 mongoengine.PULL 从ListField（ReferenceField）的任何对象字段中删除对对象的引用（使用MongoDB的“拉”操作 ）。 Generic reference fields 还存在第二种参考字段 GenericReferenceField。这允许您引用任何类型的Document，因此不会将 Document子类用作构造函数参数： class Link(Document): url = StringField() class Post(Document): title = StringField() class Bookmark(Document): bookmark_object = GenericReferenceField() link = Link(url='http://hmarr.com/mongoengine/') link.save() post = Post(title='Using MongoEngine') post.save() Bookmark(bookmark_object=link).save() Bookmark(bookmark_object=post).save() 使用GenericReferenceFields的效率略低于标准ReferenceFields，因此，如果您仅引用一种文档类型，则首选标准 ReferenceField。 唯一性约束 MongoEngine允许您通过提供unique=True给Field的构造函数来指定字段在整个集合中应该是唯一的。如果您尝试保存一个唯一字段具有与数据库中已有文档相同值的文档， NotUniqueError则会引发a。您还可以使用来指定多字段唯一性约束unique_with，该约束可以是单个字段名称，也可以是字段名称的列表或元组： class User(Document): username = StringField(unique=True) first_name = StringField() last_name = StringField(unique_with='first_name') Document collections 文件集合 直接继承自的文档类Document 将在数据库中拥有自己的集合。集合的名称默认情况下是类的名称，转换为小写形式（因此在上面的示例中，集合称为page）。如果您需要更改集合的名称（例如，将MongoEngine与现有数据库一起使用），请创建meta在文档上调用的类字典属性，并将其设置collection为您希望文档类使用的集合的名称： class Page(Document): title = StringField(max_length=200, required=True) meta = {'collection': 'cmsPage'} Capped collections 上限集合 一个Document可使用加盖收集指定 max_documents并max_size在meta字典中。 max_documents是允许在集合中存储的最大文档数，并且max_size是集合的最大大小（以字节为单位）。max_size由MongoDB内部和mongoengine向上舍入到256的下一个整数倍。也请使用256的倍数以避免混淆。如果max_size未指定， max_documents则max_size默认为10485760字节（10MB）。下面的示例显示一个Log文档，该文档将被限制为1000个条目和2MB的磁盘空间： class Log(Document): ip_address = StringField() meta = {'max_documents': 1000, 'max_size': 2000000} ordering 您可以QuerySet使用的ordering属性 为您指定默认顺序 meta。排序会在QuerySet创建时应用 ，并且可以通过后续调用来覆盖order_by()。 from datetime import datetime class BlogPost(Document): #location = PointField(auto_index=False) title = StringField() published_date = DateTimeField() meta = { 'ordering': ['-published_date'] } blog_post_1 = BlogPost(title=\"Blog Post #1\") blog_post_1.published_date = datetime(2010, 1, 5, 0, 0 ,0) blog_post_2 = BlogPost(title=\"Blog Post #2\") blog_post_2.published_date = datetime(2010, 1, 6, 0, 0 ,0) blog_post_3 = BlogPost(title=\"Blog Post #3\") blog_post_3.published_date = datetime(2010, 1, 7, 0, 0 ,0) blog_post_1.save() blog_post_2.save() blog_post_3.save() # get the \"first\" BlogPost using default ordering # from BlogPost.meta.ordering latest_post = BlogPost.objects.first() assert latest_post.title == \"Blog Post #3\" # override default ordering, order BlogPosts by \"published_date\" first_post = BlogPost.objects.order_by(\"+published_date\").first() assert first_post.title == \"Blog Post #1 文件继承 要创建Document您定义的专用类型，可以将其子类化，并添加您可能需要的任何其他字段或方法。由于此新类不是的直接子类 Document，因此不会存储在其自己的集合中。它将使用与其超类相同的集合。这样可以更方便，有效地检索相关文档–您需要做的所有事情都allow_inheritance在meta文档数据中设置为True 。 # Stored in a collection named 'page' class Page(Document): title = StringField(max_length=200, required=True) meta = {'allow_inheritance': True} # Also stored in the collection named 'page' class DatedPage(Page): date = DateTimeField() Page(title='a funky title').save() DatedPage(title='another title', date=datetime.utcnow()).save() print(Page.objects().count()) # 2 print(DatedPage.objects().count()) # 1 # print documents in their native form # we remove 'id' to avoid polluting the output with unnecessary detail qs = Page.objects.exclude('id').as_pymongo() print(list(qs)) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"mongo/mongoengine-document-instances.html":{"url":"mongo/mongoengine-document-instances.html","title":"3.4.3 应用实例","keywords":"","body":"3.1.3 Documents instances 要创建一个新的文档对象，请创建相关文档类的实例，为其字段提供值作为构造函数关键字参数。您可以为文档中的任何字段提供值： >>> page = Page(title=\"Test Page\") >>> page.title 'Test Page' 还可以使用标准对象属性语法将值分配给文档的字段 >>> page.title = \"Example Page\" >>> page.title 'Example Page 二、保存和删除文件 MongoEngine跟踪对文档的更改以提供有效的保存。要将文档保存到数据库，请调用save()方法。如果文档在数据库中不存在，则会创建该文档。如果已经存在，则所有更改都将自动更新。例如： >>> page = Page(title=\"Test Page\") >>> page.save() # Performs an insert >>> page.title = \"My Page\" >>> page.save() # Performs an atomic set on the title field. 跟踪文档的更改，并总体上执行set操作。 list_field.push(0) 设置结果列表 del(list_field) 取消整个列表 With列表更适合使用，Doc.update(push__list_field=0)因为这样可以阻止整个列表的更新-停止任何竞争条件。 三、级联保存 如果您的文档包含ReferenceField或 GenericReferenceField对象，则默认情况下该 save()方法将不会保存对那些对象的任何更改。如果您还希望保存所有引用，请注意每个保存是一个单独的查询，然后将cascadeTrue传递给save方法将级联所有保存。 四、删除文件 要删除文档，请调用delete()方法。请注意，这仅在文档存在于数据库中且具有有效时才起作用id。 文件编号 数据库中的每个文档都有唯一的ID。可以通过对象id上的属性进行访问 Document。通常，保存对象时，数据库服务器会自动生成ID，这意味着您仅id在保存文档后才能访问该字段： >>> page = Page(title=\"Test Page\") >>> page.id >>> page.save() >>> page.id ObjectId('123456789abcdef000000000') 或者，您可以通过为primary_key=True字段的构造函数提供关键字参数来将自己的字段之一定义为文档的“主键” 。在幕后，MongoEngine将使用此字段作为 id; 实际上实际上id是别名为您的主键字段，因此您可以根据需要使用以下id方式访问主键： >>> class User(Document): ... email = StringField(primary_key=True) ... name = StringField() ... >>> bob = User(email='bob@example.com', name='Bob') >>> bob.save() >>> bob.id == bob.email == 'bob@example.com' True 您还可以使用pk字段访问文档的“主键” ，它是以下内容的别名id： >>> page = Page(title=\"Another Test Page\") >>> page.save() >>> page.id == page.pk True 注意 如果定义自己的主键字段，则该字段隐式成为必填字段，因此，ValidationError如果不提供该字段，则将引发 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"elasticsearch/elasticsearch-introduce.html":{"url":"elasticsearch/elasticsearch-introduce.html","title":"4.Elasticsearch","keywords":"","body":"Relational DB -> Databases 数据库 -> Tables 表 -> Rows 行 -> Columns 列 Elasticsearch -> Indices 索引库 -> Types 类型 -> Documents 文档 -> Fields 字段/属性 一、Elasticsearch中的核心概念 索引 index 一个索引就是一个拥有几分相似特征的文档的集合 比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引 一个索引由一个名字来标识(必须全部是小写字母的)，并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字 映射 mapping ElasticSearch中的映射(Mapping)用来定义一个文档 mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的 字段Field 相当于是数据表的字段|列 字段类型Type 每一个字段都应该有一个对应的类型，例如:Text、Keyword、Byte等 文档 document 一个文档是一个可被索引的基础信息单元，类似一条记录 文档以JSON(Javascript Object Notation)格式来表示 集群 cluster 一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能 节点 node 一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中 这意味着，如果在网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中 在一个集群里，可以拥有任意多个节点，而且，如果当前网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。 分片和副本 shards&replicas 分片 一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间;或者单个节点处理搜索请求，响应太慢 为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片 当创建一个索引的时候，可以指定你想要的分片的数量 每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上 分片很重要，主要有两方面的原因①允许水平分割/扩展你的内容容量②允许在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量 至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户来说，这些都是透明的 副本 在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于腐线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的 Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做副本分片，或者直接叫副本 副本之所以重要，有两个主要原因 ①在分片/节点失败的情况下，操供了高可用性。 注意到复制分片从不与原/主要(original/primary)分片置于同一节点上是非常重要的 ②扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行运行 每个索引可以被分成多个分片。一个索引有0个或者多个副本 一旦设置了副本，每个索引就有了主分片和副本分片，分片和副本的数量可以在索引创建的时候指定 在索引创建之后，可以在任何时候动态地改变副本的数量，但是不能改变分片的数量 映射 mapping 映射 mapping 映射 mapping 映射 mapping window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"elasticsearch/elasticsearch-connect.html":{"url":"elasticsearch/elasticsearch-connect.html","title":"4.1 基础操作","keywords":"","body":" 创建index索引 创建索引my-index es.indices.create(index='my-index') 索引my-index,如果已经存在，就返回个400， es.indices.create(index='my-index',ignore=[400]) 插入数据 es.get(index='index_name', doc_type='tpye_name', id='id_value') es.index( index=\"my-index\", doc_type=\"test-type\", id=1, body={\"unsername\": \"python\", \"sex\":1, \"\":18, \"timestamp\":datetime.now()} ) get查询获取数据 es.get(index=\"my-index\", doc_type=\"test-type\", id=1) search 查询获取数据 es.search(index=\"my-index\", doc_type=\"test-type\") search 查询所有数据 match_all es.search(index=\"my-index\", doc_type=\"test-type\") body = {\"query\": {\"match_all\": {}}} es.search(index=\"my-index\", doc_type=\"test-type\", body=body) search 条件查询数据 term 搜索name=\"python\" 的数据 搜索name=\"python\" 的数据 body = { \"query\": { \"term\": { \"username\":\"python\" } } } search 条件查询数据 terms 搜索username=\"python\"或username=\"java\" 的数据 搜索username=\"python\"或username=\"java\" 的数据 body = { \"query\": { \"terms\": { \"username\": [\"python\", \"java\"] } } } search 条件查询数据 match match ： 关键字匹配的数据(匹配库中单个field) ; 分词后结果 python 与 python1 为两个不同的词 查询username 包含 python 的数据 查询username 包含 python 的数据 body = { \"query\": { \"match\": { \"username\": \"python\" } } } search 条件查询数据 multi_match multi_match 关键字匹配的数据(匹配库中多个field) ; 查询username 和 addr 包含\"python\"关键字的数据 查询 username 和 addr 包含\"python\"关键字的数据 body = { \"query\": { \"multi_match\": { \"query\": \"python\", \"fields\": [\"username\", \"addr\"] } } } search 条件查询 ids 查询 id为1 或 2d 的数据 查询 id为1 或 2d 的数据 body = { \"query\": { \"ids\": { \"type\": \"test-type\", \"values\": [1, 2] } } } search 复合查询 bool bool有3类查询关系 must(都满足) should(其中一个满足) must_not(都不满足) 查询 username=\"python\" and \"age\"=18 的数据 查询 username=\"python\" and \"age\"=18 的数据 body = { \"query\": { \"bool\": { \"must\": [ { \"term\": {\"username\": \"python\"} }, { \"term\": {\"age\": 18} } ] } } } search 范围查询 range 查询age大于18且age小于30 的数据 查询age大于18且age小于30 的数据 body = { \"query\": { \"range\": { \"age\": { \"gte\": 18, \"lte\": 30 } } } } search 排序 sort 根据某个字段升序排序 \"order\": \"asc\" asc升序，desc降序 根据age字段升序排序 根据age字段升序排序 body = { \"query\": { \"match_all\": {} }, \"sort\": { \"age\": {\"order\": \"asc\"} } } count 执行查询并获取该查询的匹配数 es.count(index=\"my-index\", doc_type=\"test-type\") es.count(index=\"my-index\", doc_type=\"test-type\", body=body) 获取最值 aggs 搜索所有数据，并获取age最大的值 搜索所有数据，并获取age最大的值 body = { \"query\": { \"match_all\": {} }, \"aggs\": { # 聚合查询 \"max_age\": { # 最大值的key \"max\": {\"field\": \"age\"} # 最大 查询\"age\"的最大值 } } } 获取和 搜索所有数据，并获取age和 搜索所有数据，并获取age和 body = { \"query\": { \"match_all\": {} }, \"aggs\": { # 聚合查询 \"sum_age\": { # 和的key \"sum\": {\"field\": \"age\"} # 和 获取所有age的和 } } } 获取平均值 搜索所有数据，并获取age平均值 搜索所有数据，并获取age平均值 body = { \"query\": { \"match_all\": {} }, \"aggs\": { # 聚合查询 \"avg_age\": { # 平均的key \"sum\": {\"field\": \"age\"} # 平均值 获取所有age的平均值 } } } filter_path 响应过滤 只需要获取_id数据,多个条件用逗号隔开 es.search(index=\"my-index\", doc_type=\"test-type\", filter_path=[\"hits.hits._id\"]) 获取所有数据 es.search(index=\"my-index\", doc_type=\"test-type\", filter_path=[\"hits.hits._*\"]) 通配符查询 查询name以id为后缀的所有数据 查询name以id为后缀的所有数据 body = { \"query\": { \"wildcard\": { \"name\": \"*id\" } } } 前缀查询 查询前缀为\"赵\"的所有数据 查询前缀为\"赵\"的所有数据 body = { \"query\": { \"prefix\": { \"username\": \"p\" } } } 切片式查询 从第2条数据开始，获取4条数据 从第2条数据开始，获取4条数据 body = { \"query\": { \"match_all\": {} }, \"from\": 2, 从第二条数据开始 \"size\": 4 获取4条数据 } 删除数据 delete：删除指定index、type、id的文档 es.delete(index=\"my-index\", doc_type=\"test-type\", id=1) es.delete(index=\"my-index\", doc_type=\"test-type\", id=1, ignore=[404]) 不存在则404 可忽略 条件删除 delete_by_query：删除满足条件的所有数据，查询条件必须符合DLS格式 query = {'query': {'match': {'sex': 'famale'}}} # 删除性别为女性的所有文档 query = {'query': {'range': {'age': {'lt': 11}}}}# 删除年龄小于11的所有文档 es.delete_by_query(index='indexName', body=query, doc_type='typeName') 条件更新 update_by_query：更新满足条件的所有数据，写法同上删除和查询 批量写入、删除、更新 bulk 如果想存在即更新, 不存在则更新，加一个 doc_as_upsert 参数就好了 datas = { \"_index\": f\"online_complex_test\", \"_op_type\": \"update\", \"_type\": f\"complex_city\", \"_id\": id, 'doc': doc, \"doc_as_upsert\": True } ​ 基础操作 import pymongo, json from elasticsearch import Elasticsearch from elasticsearch import helpers import math # mapping 定义你的es字段 doc_mapping = { 'properties': { \"other_id\": {\"type\": \"long\"}, \"city\": {\"type\": \"keyword\"}, \"id\": {\"type\": \"keyword\"}, } } # 创建ES连接 es_conn_test = Elasticsearch([\"127.0.0.1:6666\"], maxsize=25) # es的基础配置, index_name, alias(别名可以创建多个), doc_type(表名) index_name = f'complex_test' online_alias = f'online_complex_test' type_name = f'complex_city' es_conn_test.indices.create(index=index_name, ignore=400) es_conn_test.indices.put_mapping(index=index_name, doc_type=type_name, body=doc_mapping) es_conn_test.indices.put_alias(index_name, online_alias) # 别名 # 获取mapping res = es_conn_test.indices.get_mapping(index=index_name) print(json.dumps(res)) # es查询 res = es_conn_test.search(index=index_name, doc_type=type_name, body={}) print(json.dumps(res)) # 删除索引 res = es_conn_test.indices.delete(index=index_name) print(res) window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "}}