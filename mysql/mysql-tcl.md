## 第七章 TCL语言

### 7.1、事务

**一、含义**

一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行

**二、特点（ACID）**

1. 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行
2. 一致性：一个事务的执行不能破坏数据库数据的完整性和一致性
3. 隔离性：一个事务不受其它事务的干扰，多个事务是互相隔离的
4. 持久性：一个事务一旦提交了，则永久的持久化到本地

**三、分类**

1. 隐式事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete

2. 显式事务：具有明显的开启和结束, 例如以下格式：

   <font color=red> 开启事务  </font>
   
   ```sql
   set autocommit=0;    关闭自动提交
   start transaction;   开启事务机制
   ```

   <font color=red>编写一组逻辑sql语句  </font>sql语句支持的是insert、update、delete
   ```sql
      【设置回滚点，可选项】
      savepoint 回滚点名;
   ```

   <font color=red> 结束事务  </font>
   ```sql
   提交：commit;
   回滚：rollback;
   回滚到指定的地方： rollback to 回滚点名;
   ```

### 7.2、事务并发（读问题）

**一、事物的并发问题如何发生？**

多个事务同时操作同一个数据库的相同数据时

**二、事务的并发问题都有哪些？**

1. 脏读：一个事务读到了另一个事务还未提交的update数据，导致多次查询的结果不一样
2. 不可重复读：一个事务读到了另一个事务已经提交的update数据，导致多次查询结果不一致
3. 幻读：一个事务读到了另一个事务已经提交的insert数据，导致多次查询的结果不一样

**三、事物的并发问题如何解决？**

通过设置隔离级别来解决并发问题

**四、隔离级别**

| 隔离级别         | 隔离描述 | 脏读 | 不可重复读 | 幻读 |
| ---------------- | -------- | ---- | ---------- | ---- |
| READ UNCOMMITTED | 读未提交 | ×    | ×          | ×    |
| READ COMMITTED   | 读已提交 | √    | ×          | ×    |
| REPEATABLE READ  | 可重复读 | √    | √          | ×    |
| SERIALIZABLE     | 串行化   | √    | √          | √    |

**五、注意问题**

```sql
mysql    中默认第三个隔离级别 REPEATABLE READ
oracle   中默认第二个隔离级别 READ COMMITTED
```
```sql
查看隔离级别 SELECT @@tx_isolation;
设置隔离级别 SET SESSION|GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别;
```

### 7.3、丢失更新（写问题）

**一、定义**

在事务的隔离级别内容中，能够了解到两个不同的事务在并发的时候可能会发生数据的影响。细心的话可以发现事务隔离级别章节中，脏读、不可重复读、幻读三个问题都是由事务A对数据进行修改、增加，事务B总是在做读操作。如果两事务都在对数据进行修改则会导致另外的问题：丢失更新。

**二、解决**

- 悲观锁：认为两个事务更新操作一定会发生丢失更新

  解决：通过在语句后边添加for update来实现行级上锁，所以又称为“行级锁”

  例如：`select * from t_account t wheret.id=‘1’ for update;`

- 乐观锁：认为事务不一定会产生丢失更新，让事务进行并发修改，不对事务进行锁定

  解决：由程序员自己解决，可以通过给数据表添加自增的version字段或时间戳timestamp，进行数据修改时，数据库会检测version字段或者时间戳是否与原来的一致，若不一致，抛出异常或者重新查询

**三、注意**

对于  <font color=red>账户交易建议直接使用悲观锁</font>，数据库的性能很高，并发度不是很高的场景两者性能没有太大差别。如果是  <font color=red>交易减库存的操作可以考虑乐观锁</font>，保证并发度。



#### [事务补充与解读](https://blog.csdn.net/a6864657/article/details/79671302)

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。
也就是事务具有原子性, 一个事务中的一系列的操作要么全部成功，要么一个都不做。

- 原子性 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做

- 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。

  如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。

- 隔离性  一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

- 持久性 指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

#### 数据库系统必须维护事务的以下特性 ：

原子性 、一致性 、隔离性 、持久性 事务中的所有操作要么全部执行，要么都不执行；

如果事务没有原子性的保证，那么在发生系统 故障的情况下，数据库就有可能处于不一致状态。

事务的结束有两种:1.当事务中的所以步骤全部成功执行时，事务提交。2.如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。

# 举个例子：

A想要从自己的帐户中转3000块钱到B的帐户里。那个从A开始转帐，到转帐结束的这一个过程，称之为一个事务。在这个事务里，要做如下操作：

从A的帐户中减去3000块钱。如果A的帐户原来有3000块钱，现在就变成0块钱了。

在B的帐户里加3000块钱。如果B的帐户如果原来有0块钱，现在则变成3000块钱了。

如果在A的帐户已经减去了3000块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时B的帐户里还没有增加3000块钱。那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到A的帐户还没减3000块的状态，B的帐户的原来的状态。此时A的帐户仍然有3000块，B的帐户仍然有0块。（一致性）

我们把这种要么一起成功（A帐户成功减少3000，同时B帐户成功增加3000），要么一起失败（A帐户回到原来状态，B帐户也回到原来状态）的操作叫原子性操作。

如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性



















